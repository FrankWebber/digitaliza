Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\app.py:


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\ocr_processor.py:
import boto3
import time
from dotenv import load_dotenv
import os

# Carrega as variáveis do arquivo .env
load_dotenv()

# Acessando as variáveis de ambiente
AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
AWS_REGION = os.getenv('AWS_REGION')
S3_BUCKET_NAME = os.getenv('S3_BUCKET_NAME')

# Inicializa o cliente do Textract
textract = boto3.client('textract', aws_access_key_id=AWS_ACCESS_KEY_ID, 
                         aws_secret_access_key=AWS_SECRET_ACCESS_KEY, 
                         region_name=AWS_REGION)

def process_document(bucket_name, document_name):
    # Inicia o processamento do documento
    response = textract.start_document_text_detection(
        DocumentLocation={'S3Object': {'Bucket': bucket_name, 'Name': document_name}}
    )

    # Salvar o JobId para verificar o status do processamento
    job_id = response['JobId']
    
    # Aguardar até que o Textract conclua o processamento
    while True:
        response = textract.get_document_text_detection(JobId=job_id)
        
        if 'JobStatus' in response and response['JobStatus'] in ['SUCCEEDED', 'FAILED']:
            break
        
        print("Aguardando...")  # Mensagem de status
        time.sleep(5)  # Aguardar 5 segundos entre as verificações
    
    return response

def extract_text_and_save(response, output_txt_path):
    with open(output_txt_path, 'w', encoding='utf-8') as txt_file:
        for item in response.get('Blocks', []):
            if item['BlockType'] == 'LINE':
                txt_file.write(item['Text'] + '\n')

def check_ocr_status(job_id):
    textract = boto3.client('textract', aws_access_key_id=AWS_ACCESS_KEY_ID, 
                             aws_secret_access_key=AWS_SECRET_ACCESS_KEY, 
                             region_name=AWS_REGION)

    # Chama a API para verificar o status do trabalho
    response = textract.get_document_analysis(JobId=job_id)

    # Lógica para tratar os diferentes estados do job
    if response['JobStatus'] == 'SUCCEEDED':
        return response
    elif response['JobStatus'] in ['FAILED', 'PARTIAL_SUCCESS']:
        raise Exception(f"O processamento falhou com o status: {response['JobStatus']}")
    else:
        return None  # Retorna None se o job ainda está em processamento

# Uso da função
if __name__ == "__main__":
    # Defina o nome do bucket e o arquivo PDF que foi enviado
    bucket_name = S3_BUCKET_NAME  # Obtém o nome do bucket do arquivo .env
    uploaded_pdf = 'example.pdf'  # Nome do arquivo PDF que foi enviado

    # Processa o documento
    response = process_document(bucket_name, uploaded_pdf)

    # Salvar texto extraído
    output_txt_path = r"C:\Users\Frank Webber\Documents\GitHub\digita-liza\results\resultado.txt"
    extract_text_and_save(response, output_txt_path)

    print("Texto extraído salvo em:", output_txt_path)


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\LogErrorButton.js:
// src/components/LogErrorButton.js
import React from 'react';

const LogErrorButton = () => {
    const handleLogError = async () => {
        try {
            const response = await fetch('http://localhost:5000/log-error', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ error: 'This is a test error for logging.' }),
            });

            if (!response.ok) {
                throw new Error('Failed to log error');
            }

            const data = await response.json();
            alert(data.message); // Exibe uma mensagem de sucesso
        } catch (error) {
            console.error('Error logging error:', error);
            alert('Failed to log error');
        }
    };

    return (
        <button onClick={handleLogError}>
            Log Error
        </button>
    );
};

export default LogErrorButton;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\DownloadText.js:
import React from 'react';

const DownloadText = ({ text, filename }) => {
  const downloadFile = () => {
    const blob = new Blob([text], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = ${filename}.txt;
    link.click();
  };

  return (
    <div>
      <button onClick={downloadFile} disabled={!text}>
        Baixar Texto Extraído
      </button>
    </div>
  );
};

export default DownloadText;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\OCRButton.js:
import React, { useState } from 'react';

// Componente UploadForm para upload de PDF
const UploadForm = ({ onUploadSuccess, setJobId, setFilename }) => {
    const [file, setFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);

    const handleFileChange = (event) => {
        const selectedFile = event.target.files[0];
        console.log('Arquivo selecionado:', selectedFile);
        setFile(selectedFile);  // Atualiza o estado com o arquivo selecionado
    };

    const handleUpload = async (event) => {
        event.preventDefault();

        if (!file) {
            alert('Por favor, selecione um arquivo para upload.');
            return;
        }

        const formData = new FormData();
        formData.append('file', file);  // Adiciona o arquivo ao FormData

        console.log('FormData pronto:', formData.get('file')); // Log para depuração

        setIsUploading(true);  // Inicia o processo de upload

        try {
            const response = await fetch('http://127.0.0.1:5000/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Erro ao fazer upload do arquivo.');
            }

            const data = await response.json();
            alert('Arquivo enviado com sucesso!');
            setJobId(data.jobId);  // Atualiza o jobId
            setFilename(file.name); // Atualiza o filename
            setFile(null);  // Limpa o arquivo selecionado após o upload
            
            // Retorna o jobId para o OCRButton
            return data.jobId;  
        } catch (error) {
            alert(Erro ao enviar arquivo: ${error.message});  // Mensagem de erro
        } finally {
            setIsUploading(false);  // Finaliza o processo de upload
        }
    };

    return (
        <form onSubmit={handleUpload}>
            <input
                type="file"
                accept=".pdf"  // Limita a seleção apenas para arquivos PDF
                onChange={handleFileChange}
                disabled={isUploading}  // Desabilita o input durante o upload
            />
            <button type="submit" disabled={isUploading}>
                {isUploading ? 'Enviando...' : 'Enviar PDF'}
            </button>
        </form>
    );
};

// Componente OCRButton para processar OCR
const OCRButton = ({ file, onOCR, setTxtFilePath }) => { 
    const [jobId, setJobId] = useState(null);
    const [status, setStatus] = useState(null);

    const handleClick = async () => {
        console.log('Arquivo enviado:', file);

        try {
            const formData = new FormData();
            formData.append('file', file);

            const startResponse = await fetch('http://127.0.0.1:5000/upload', {
                method: 'POST',
                body: formData,
            });

            if (!startResponse.ok) {
                throw new Error('Erro ao iniciar o OCR');
            }

            const { jobId: newJobId } = await startResponse.json();
            setJobId(newJobId);

            const statusInterval = setInterval(async () => {
                const statusResponse = await fetch(http://127.0.0.1:5000/ocr-status/${newJobId}, {
                    method: 'GET',
                });

                if (!statusResponse.ok) {
                    throw new Error('Erro ao verificar status do OCR');
                }

                const { status, txt_path } = await statusResponse.json();
                setStatus(status);

                if (txt_path) {
                    setTxtFilePath(txt_path); // Armazena o caminho do arquivo txt
                    alert(Arquivo TXT salvo em: ${txt_path}); // Informa o usuário sobre o caminho do arquivo
                }

                if (status === 'SUCCEEDED') {
                    clearInterval(statusInterval);  
                    onOCR(txt_path);  
                }
            }, 5000);  
        } catch (error) {
            console.error('Erro ao processar OCR:', error);
        }
    };

    return (
        <div>
            <button onClick={handleClick} disabled={!file}>
                Processar OCR
            </button>
            {status && <p>Status do OCR: {status}</p>}
        </div>
    );
};

// Exportando ambos os componentes como nomeados
export { UploadForm, OCRButton };


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\Relatorio.js:
import React, { useState, useEffect } from 'react';

const Relatorio = () => {
  const [logs, setLogs] = useState([]);
  const [loading, setLoading] = useState(true);

  // Função para buscar logs do backend
  const fetchLogs = async () => {
    setLoading(true);
    try {
      const response = await fetch('http://127.0.0.1:5000/logs'); // Endpoint que você precisa implementar no backend
      if (!response.ok) {
        throw new Error('Erro ao buscar logs do servidor');
      }
      const data = await response.json();
      setLogs(data.logs || []);
    } catch (error) {
      console.error('Erro ao buscar logs:', error);
      setLogs(['Erro ao buscar logs']);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchLogs();
    const interval = setInterval(fetchLogs, 1000); // Atualiza os logs a cada 1 segundos
    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h3>Relatório de Atividades do Backend</h3>
      {loading ? (
        <p>Carregando logs...</p>
      ) : (
        <ul>
          {logs.map((log, index) => (
            <li key={index}>{log}</li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default Relatorio;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\UploadForm.js:
import React, { useState } from 'react';

function UploadForm({ onUploadSuccess, setJobId, setFilename, setTxtFilePath }) {
    const [file, setFile] = useState(null);
    const [isUploading, setIsUploading] = useState(false);

    const handleFileChange = (event) => {
        const selectedFile = event.target.files[0];  // Captura o primeiro arquivo selecionado
        console.log('Arquivo selecionado:', selectedFile);  // Adiciona o log aqui para depuração
        setFile(selectedFile);  // Atualiza o estado com o arquivo selecionado
    };

    const handleUpload = async (event) => {
        event.preventDefault();

        if (!file) {
            alert('Por favor, selecione um arquivo para upload.');
            return;
        }

        const formData = new FormData();
        formData.append('file', file);  // Adiciona o arquivo ao FormData

        console.log('FormData pronto:', formData.get('file')); // Log para depuração

        setIsUploading(true);  // Inicia o processo de upload

        try {
            const response = await fetch('http://127.0.0.1:5000/upload', {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Erro ao fazer upload do arquivo.');
            }

            const data = await response.json();
            alert('Arquivo enviado com sucesso!');
            setJobId(data.jobId);  // Atualiza o jobId
            setFilename(file.name); // Atualiza o filename
            setFile(null);  // Limpa o arquivo selecionado após o upload
            
            // Verifica o status do OCR automaticamente
            const statusResponse = await fetch(http://127.0.0.1:5000/ocr-status/${data.jobId}, {
                method: 'GET',
            });

            if (statusResponse.ok) {
                const { status, txt_path } = await statusResponse.json();
                if (txt_path) {
                    setTxtFilePath(txt_path); // Armazena o caminho do arquivo txt
                }
                console.log(Arquivo TXT salvo em: ${txt_path}); // Log do caminho do arquivo
            }

            // Chama a função de sucesso
            if (onUploadSuccess) {
                onUploadSuccess();  // Atualiza a lista de PDFs após o upload
            }
        } catch (error) {
            alert(Erro ao enviar arquivo: ${error.message});  // Mensagem de erro
        } finally {
            setIsUploading(false);  // Finaliza o processo de upload
        }
    };

    return (
        <form onSubmit={handleUpload}>
            <input
                type="file"
                accept=".pdf"  // Limita a seleção apenas para arquivos PDF
                onChange={handleFileChange}
                disabled={isUploading}  // Desabilita o input durante o upload
            />
            <button type="submit" disabled={isUploading}>
                {isUploading ? 'Enviando...' : 'Enviar PDF'}
            </button>
        </form>
    );
}

export default UploadForm;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\ConsoleOutput.js:
// src/components/ConsoleOutput.js
import React, { useState, useEffect } from 'react';

const ConsoleOutput = ({ jobId, filename }) => {
  const [messages, setMessages] = useState([]);
  const [uploading, setUploading] = useState(false);
  const [ocrStatus, setOcrStatus] = useState(null);

  useEffect(() => {
    if (jobId) {
      const statusInterval = setInterval(async () => {
        try {
          const response = await fetch(http://127.0.0.1:5000/ocr-status/${jobId});
          if (!response.ok) {
            throw new Error('Erro ao verificar status do OCR');
          }

          const data = await response.json();
          setOcrStatus(data.status);
          addMessage(Status do OCR: ${data.status});

          if (data.status === 'SUCCEEDED' || data.status === 'FAILED') {
            clearInterval(statusInterval);
          }
        } catch (error) {
          console.error('Erro ao verificar status do OCR:', error);
        }
      }, 5000); // Verifica o status a cada 5 segundos

      return () => clearInterval(statusInterval); // Limpa o intervalo ao desmontar
    }
  }, [jobId]);

  const addMessage = (message) => {
    setMessages((prevMessages) => [...prevMessages, message]);
  };

  return (
    <div style={{
      background: '#1e1e1e',
      color: '#ffffff',
      padding: '20px',
      borderRadius: '5px',
      height: '300px',
      overflowY: 'scroll',
      fontFamily: 'monospace',
    }}>
      <h3>Status do Console</h3>
      <div>
        {messages.map((msg, index) => (
          <div key={index}>{msg}</div>
        ))}
      </div>
      {uploading && <p>Upload em andamento...</p>}
      {filename && <p>Arquivo: {filename}</p>}
      {ocrStatus && <p>Status do OCR: {ocrStatus}</p>}
    </div>
  );
};

export default ConsoleOutput;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\App.js:
import React, { useState, useEffect } from 'react';
import PDFList from './components/PDFList';
import UploadForm from './components/UploadForm';
import PDFDetails from './components/PDFDetails';
import ConsoleOutput from './components/ConsoleOutput'; // Importa o ConsoleOutput
import './App.css';

function App() {
  const [pdfs, setPdfs] = useState([]);
  const [selectedPdf, setSelectedPdf] = useState(null);
  const [jobId, setJobId] = useState(null);
  const [filename, setFilename] = useState(null);
  const [txtFilePath, setTxtFilePath] = useState(null); // Para armazenar o caminho do arquivo .txt

  const fetchPDFs = async () => {
    try {
      const response = await fetch('http://localhost:5000/status');
      if (!response.ok) {
        throw new Error('Erro ao buscar o status dos PDFs');
      }
      const data = await response.json();
      const pdfList = Object.keys(data).map(key => ({ filename: key, status: data[key].status }));
      setPdfs(pdfList);
    } catch (error) {
      console.error('Error fetching PDF status:', error);
      alert("Ocorreu um erro ao buscar o status dos PDFs. Verifique se o backend está funcionando.");
    }
  };

  useEffect(() => {
    fetchPDFs();
  }, []);

  return (
    <div className="App">
      <h1>DigitalizaLaudos</h1>
      <UploadForm 
        onUploadSuccess={fetchPDFs} 
        setJobId={setJobId} 
        setFilename={setFilename} 
        setTxtFilePath={setTxtFilePath} // Não esqueça de passar isso
      />
      <PDFList pdfs={pdfs} onSelectPdf={setSelectedPdf} />
      {selectedPdf && <PDFDetails filename={selectedPdf.filename} />}
      {txtFilePath && <p>Arquivo TXT salvo em: {txtFilePath}</p>} {/* Exibe o caminho do arquivo txt */}
      <ConsoleOutput jobId={jobId} filename={filename} /> {/* Adiciona o ConsoleOutput */}
    </div>
  );
}

export default App;