Download the React DevTools for a better development experience: https://reactjs.org/link/react-devtools
UploadForm.js:25 Download the React DevTools for a better development experience: https://reactjs.org/link/react-devtools
UploadForm.js:25 
        
        
       POST http://127.0.0.1:5000/upload 500 (INTERNAL SERVER ERROR)
handleUpload @ UploadForm.js:25
callCallback @ react-dom.development.js:4164
invokeGuardedCallbackDev @ react-dom.development.js:4213
invokeGuardedCallback @ react-dom.development.js:4277
invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:4291
executeDispatch @ react-dom.development.js:9041
processDispatchQueueItemsInOrder @ react-dom.development.js:9073
processDispatchQueue @ react-dom.development.js:9086
dispatchEventsForPlugins @ react-dom.development.js:9097
(anonymous) @ react-dom.development.js:9288
batchedUpdates$1 @ react-dom.development.js:26179
batchedUpdates @ react-dom.development.js:3991
dispatchEventForPluginEventSystem @ react-dom.development.js:9287
dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay @ react-dom.development.js:6465
dispatchEvent @ react-dom.development.js:6457
dispatchDiscreteEvent @ react-dom.development.js:6430
Show 15 more frames
Show lessUnderstand this error
        
          
            
              Explanation
            
          
          
            
          
                
          
          
          
        
          
        
        
        
          
        Okay, let's troubleshoot this 500 Internal Server Error when uploading a file to your Flask backend. The Problem:The error indicates that your Flask application encountered an issue while processing the uploaded file. This could be due to several reasons, including:File Size Limits: Your Flask application might have a limit on the maximum file size it can handle. If the uploaded file exceeds this limit, it will result in a 500 error.Missing or Incorrect File Handling: Your Flask route (/upload) might be missing the necessary code to handle the uploaded file (e.g., saving it to disk, processing it).Server-Side Errors: There might be errors in your Python code that are causing the server to crash or fail during the upload process. This could be due to incorrect file type handling, database errors, or other issues.Memory Issues: If the uploaded file is very large, it might consume too much memory on the server, leading to a 500 error.Incorrect File Format: The file format might not be supported or handled correctly by your backend code.Debugging Steps:Check File Size Limits:In your Flask application, ensure that the MAX_CONTENT_LENGTH setting in your app's configuration is set to a value that is larger than the size of the files you are uploading.You can adjust this limit in your Flask application like this:
      
        
        
          
            
            Copy code
          
        
      
      
        from flask import Flask     app = Flask(__name__)     app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit (adjust as needed)
        
          
            Use code snippets with caution
         
        
      
    Inspect Your Flask Route:Ensure that your Flask route (/upload) is correctly handling the uploaded file.You should use the request.files object to access the uploaded file.Example:
      
        
        
          
            
            Copy code
          
        
      
      
        from flask import Flask, request, jsonify     app = Flask(__name__)     @app.route('/upload', methods=['POST'])     def upload_file():         if 'file' not in request.files:             return jsonify({'error': 'No file part'}), 400         file = request.files['file']         if file.filename == '':             return jsonify({'error': 'No selected file'}), 400         if file:             try:                 # Save the file to a specific location (e.g., uploads folder)                 file.save('uploads/' + file.filename)                 return jsonify({'message': 'File uploaded successfully'}), 200             except Exception as e:                 return jsonify({'error': str(e)}), 500
        
          
            Use code snippets with caution
         
        
      
    Enable Debugging in Flask:Set DEBUG=True in your Flask application to enable detailed error messages in the console. This will help you identify the specific error that is causing the 500 response.Check Server Logs:Examine your server's logs (e.g., the console output if you're running Flask locally) for any error messages related to the upload process.Test with Smaller Files:Try uploading a smaller file to see if the issue is related to file size.Handle Exceptions:Wrap your file handling code in a try...except block to catch any exceptions that might occur during the upload process. This will prevent your server from crashing and allow you to return a more informative error message to the client.Example (Flask Route with Error Handling):
      
        
        
          
            
            Copy code
          
        
      
      
        from flask import Flask, request, jsonifyapp = Flask(__name__)@app.route('/upload', methods=['POST'])def upload_file():    try:        if 'file' not in request.files:            return jsonify({'error': 'No file part'}), 400        file = request.files['file']        if file.filename == '':            return jsonify({'error': 'No selected file'}), 400        if file:            file.save('uploads/' + file.filename)  # Save the file            return jsonify({'message': 'File uploaded successfully'}), 200    except Exception as e:        return jsonify({'error': str(e)}), 500
        
          
            Use code snippets with caution
         
        
      
    By following these steps, you should be able to identify the cause of the 500 error and resolve the issue with your file upload functionality. Remember to check your server logs and adjust your Flask code as needed.
      
          
            Data used to understand this message
            
        
            
            Console message
          
            
            Stacktrace
          
            
            Related code
          
            
            Network request
          
        
      
          
          
            
          
          
          
          
      Use search instead
    
        
          
        
        
        
          
              This feature may display inaccurate or offensive information that doesn't represent Google's views.
              Learn more
            
        
        
        
          
            
          
                
          
          
          
        
            
          
                
          
          
          
        
          
          
          
                
          
          
          
        
        

      
      from flask import Flask

     app = Flask(__name__)
     app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit (adjust as needed)   from flask import Flask, request, jsonify

     app = Flask(__name__)

     @app.route('/upload', methods=['POST'])
     def upload_file():
         if 'file' not in request.files:
             return jsonify({'error': 'No file part'}), 400
         file = request.files['file']
         if file.filename == '':
             return jsonify({'error': 'No selected file'}), 400
         if file:
             try:
                 # Save the file to a specific location (e.g., uploads folder)
                 file.save('uploads/' + file.filename)
                 return jsonify({'message': 'File uploaded successfully'}), 200
             except Exception as e:
                 return jsonify({'error': str(e)}), 500   from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/upload', methods=['POST'])
def upload_file():
    try:
        if 'file' not in request.files:
            return jsonify({'error': 'No file part'}), 400
        file = request.files['file']
        if file.filename == '':
            return jsonify({'error': 'No selected file'}), 400
        if file:
            file.save('uploads/' + file.filename)  # Save the file
            return jsonify({'message': 'File uploaded successfully'}), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500        
        
       POST http://127.0.0.1:5000/upload 500 (INTERNAL SERVER ERROR)
handleUpload @ UploadForm.js:25
callCallback @ react-dom.development.js:4164
invokeGuardedCallbackDev @ react-dom.development.js:4213
invokeGuardedCallback @ react-dom.development.js:4277
invokeGuardedCallbackAndCatchFirstError @ react-dom.development.js:4291
executeDispatch @ react-dom.development.js:9041
processDispatchQueueItemsInOrder @ react-dom.development.js:9073
processDispatchQueue @ react-dom.development.js:9086
dispatchEventsForPlugins @ react-dom.development.js:9097
(anonymous) @ react-dom.development.js:9288
batchedUpdates$1 @ react-dom.development.js:26179
batchedUpdates @ react-dom.development.js:3991
dispatchEventForPluginEventSystem @ react-dom.development.js:9287
dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay @ react-dom.development.js:6465
dispatchEvent @ react-dom.development.js:6457
dispatchDiscreteEvent @ react-dom.development.js:6430
Show 15 more frames
Show lessUnderstand this error  Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\package.json: 
{
  "dependencies": {
    "aws-sdk": "^2.1691.0",
    "axios": "^1.7.7",
    "cors": "^2.8.5"
  }
}


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\.gitignore:
# Ignorar o ambiente virtual do Python
venv/

# Ignorar pastas de resultados e PDFs
backend/pdfs/
backend/results/

# Ignorar arquivos de configuraÃ§Ã£o do sistema
.DS_Store
Thumbs.db

# Ignorar arquivos de log
*.log

# Ignorar arquivos de cache do Node.js
node_modules/
npm-debug.log
yarn-error.log

# Ignorar arquivos do sistema de controle de versÃ£o
.git/


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\LEIAME.txt:
# Digita-Lisa

O **Digita-Lisa** Ã© um sistema de digitalizaÃ§Ã£o e extraÃ§Ã£o de informaÃ§Ãµes automatizadas de documentos com integraÃ§Ã£o ao Amazon Textract, projetado para auxiliar a Junta MÃ©dica Pericial do Amazonas a processar laudos mÃ©dicos e outros documentos.

## Funcionalidades

- ExtraÃ§Ã£o de texto, tabelas e formulÃ¡rios de documentos digitalizados.
- Suporte a mÃºltiplas pÃ¡ginas e diferentes tipos de documentos (PDF, imagens, etc).
- AutomaÃ§Ã£o do reconhecimento de manuscritos, assinaturas e campos de valor-chave.
- IntegraÃ§Ã£o com o Amazon S3 para armazenamento de documentos processados.

## PrÃ©-requisitos

- Conta AWS ativa com permissÃµes para utilizar o **Amazon Textract** e **Amazon S3**.
- Node.js e npm instalados localmente.

## InstalaÃ§Ã£o

1. Clone o repositÃ³rio:

    
bash
    git clone https://github.com/seuprojeto/digita-lisa.git


2. Navegue atÃ© o diretÃ³rio do projeto:

    
bash
    cd digita-lisa


3. Instale as dependÃªncias do projeto:

    
bash
    npm install


4. Configure as variÃ¡veis de ambiente no arquivo .env (ver instruÃ§Ãµes abaixo).

5. Execute o projeto localmente:

    
bash
    npm start


## ConfiguraÃ§Ã£o do .env

O arquivo .env precisa ser configurado com as credenciais AWS e informaÃ§Ãµes do bucket S3. Veja a seÃ§Ã£o de variÃ¡veis de ambiente para mais detalhes.

### Exemplo de configuraÃ§Ã£o .env:

bash
AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2
S3_BUCKET_NAME=digita-lisa


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\.env:
# Credenciais AWS
AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2

# Nome do bucket S3
S3_BUCKET_NAME=digita-lisa

# ParÃ¢metros do Amazon Textract
TEXTRACT_OUTPUT_BUCKET=digita-lisa

# ConfiguraÃ§Ãµes adicionais
TEXTRACT_MAX_RETRIES=3
TEXTRACT_TIMEOUT=60000

# ParÃ¢metros de seguranÃ§a (Token JWT ou outro segredo)
JWT_SECRET=mySuperSecretToken


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\app.py:
from flask import Flask, jsonify, request
from flask_cors import CORS
import os
import boto3
import traceback
from dotenv import load_dotenv

# Carregar variÃ¡veis de ambiente
load_dotenv()

# Configurar a aplicaÃ§Ã£o Flask
app = Flask(__name__)
CORS(app)

# Configurar boto3 com as credenciais da AWS
s3_client = boto3.client(
    's3',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=os.getenv('AWS_REGION')
)

textract_client = boto3.client(
    'textract',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=os.getenv('AWS_REGION')
)

# DiretÃ³rios para armazenar PDFs e resultados
UPLOAD_FOLDER = os.path.join(os.getcwd(), 'pdfs')
RESULTS_FOLDER = os.path.join(os.getcwd(), 'results')

# Criar diretÃ³rios se nÃ£o existirem
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULTS_FOLDER, exist_ok=True)

# Nome do bucket S3
S3_BUCKET_NAME = os.getenv('S3_BUCKET_NAME')

# Lista de PDFs monitorados e seus status
pdf_files = {}

# Defina um limite para o tamanho do arquivo (opcional)
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB

@app.route('/upload', methods=['POST'])
def upload_pdf():
    try:
        if 'file' not in request.files:
            return jsonify({'error': 'No file sent'}), 400

        file = request.files['file']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400

        if file and file.filename.endswith('.pdf'):
            filepath = os.path.join(UPLOAD_FOLDER, file.filename)
            file.save(filepath)

            # Fazer upload para S3
            try:
                s3_client.upload_file(filepath, S3_BUCKET_NAME, file.filename)
            except Exception as e:
                print(f"S3 upload error: {e}")
                return jsonify({'error': 'Error uploading to S3'}), 500

            # Processar OCR no PDF enviado
            try:
                response = textract_client.analyze_document(
                    Document={'S3Object': {'Bucket': S3_BUCKET_NAME, 'Name': file.filename}},
                    FeatureTypes=["TABLES", "FORMS"]
                )
                # Aqui vocÃª pode processar a resposta do Textract conforme necessÃ¡rio
                pdf_files[file.filename] = {'status': 'processing'}
            except Exception as e:
                print(f"OCR processing error: {e}")
                return jsonify({'error': 'Error processing OCR'}), 500

            return jsonify({'message': 'PDF uploaded and OCR started', 'file': file.filename}), 200

        return jsonify({'error': 'Invalid file type, only PDFs are accepted'}), 400

    except Exception as e:
        print(f"Error occurred in upload_pdf: {traceback.format_exc()}")
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/status', methods=['GET'])
def get_status():
    return jsonify(pdf_files), 200

@app.route('/pdf/<filename>', methods=['GET'])
def get_pdf_data(filename):
    txt_file_path = os.path.join(RESULTS_FOLDER, f'{filename}.txt')
    if os.path.exists(txt_file_path):
        with open(txt_file_path, 'r') as file:
            return jsonify({'data': file.read()}), 200
    return jsonify({'error': 'File not found'}), 404

if __name__ == '__main__':
    app.run(debug=True, port=5000)


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\ocr_processor.py:
import boto3
import os
import json

def process_ocr(pdf_filename):
    s3_client = boto3.client('s3')
    bucket_name = os.getenv('S3_BUCKET_NAME')

    # Extrair o conteÃºdo do PDF do S3
    response = s3_client.get_object(Bucket=bucket_name, Key=pdf_filename)
    pdf_bytes = response['Body'].read()

    textract_client = boto3.client('textract')
    
    response = textract_client.analyze_document(
    Document={'S3Object': {'Bucket': bucket_name, 'Name': pdf_filename}},
    FeatureTypes=["TABLES", "FORMS"]
)


    blocks = response['Blocks']
    extracted_text = "\n".join([block.get('Text', '') for block in blocks if block['BlockType'] == 'LINE'])

    # Caminho para salvar o arquivo .txt
    txt_file_path = os.path.join(os.path.dirname(__file__), 'results', f'{os.path.splitext(pdf_filename)[0]}.txt')
    
    # Verifica se o diretÃ³rio de resultados existe e cria, se nÃ£o existir
    os.makedirs(os.path.dirname(txt_file_path), exist_ok=True)

    # Salvar o texto extraÃ­do em um arquivo .txt
    with open(txt_file_path, 'w') as txt_file:
        txt_file.write(extracted_text)

    return extracted_text


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\requirements.txt:
Flask==2.3.2
Werkzeug==2.3.4
requests==2.28.2
boto3==1.26.7


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\DownloadText.js:
import React from 'react';

const DownloadText = ({ text, filename }) => {
  const downloadFile = () => {
    const blob = new Blob([text], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${filename}.txt`;
    link.click();
  };

  return (
    <div>
      <button onClick={downloadFile} disabled={!text}>
        Baixar Texto ExtraÃ­do
      </button>
    </div>
  );
};

export default DownloadText;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\OCRButton.js:
import React from 'react';

const OCRButton = ({ filename, onOCR }) => {
  const handleClick = async () => {
    try {
      const response = await fetch(`http://127.0.0.1:5000/pdf/${filename}`, {
        method: 'GET',
      });

      if (!response.ok) {
        throw new Error('Erro ao solicitar OCR');
      }

      const data = await response.json();
      console.log(data);
      onOCR(data); // Chama a funÃ§Ã£o onOCR passada como prop
    } catch (error) {
      console.error('Erro ao processar OCR:', error);
    }
  };

  return (
    <button onClick={handleClick}>
      Processar OCR
    </button>
  );
};

export default OCRButton;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\PDFDetails.js:
import React, { useState } from 'react';

const PDFDetails = ({ filename }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/pdf/${filename}`);
      const result = await response.json();
      if (result.data) {
        setData(result.data);
      } else {
        setData("Nenhum texto extraÃ­do encontrado.");
      }
    } catch (error) {
      console.error('Erro ao buscar dados:', error);
      setData("Erro ao buscar dados.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={fetchData} disabled={loading}>
        {loading ? 'Carregando...' : 'Ver OCR'}
      </button>
      {data && <pre>{data}</pre>}
    </div>
  );
};

export default PDFDetails;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\PDFList.js:
import React from 'react';
import OCRButton from './OCRButton'; // Importa o OCRButton para cada PDF

const PDFList = ({ pdfs, onSelectPdf }) => {
  return (
    <div>
      <h2>Lista de PDFs Digitalizados</h2>
      <ul>
        {pdfs.map((pdf, index) => (
          <li key={index}>
            <p>{pdf.filename} - {pdf.status}</p>
            <OCRButton filename={pdf.filename} onOCR={onSelectPdf} />
          </li>
        ))}
      </ul>
    </div>
  );
};

export default PDFList;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\Relatorio.js:
import React, { useState } from 'react';

const ConsoleOutput = () => {
    const [messages, setMessages] = useState([]);

    const addMessage = (newMessage) => {
        setMessages((prevMessages) => [...prevMessages, newMessage]);
    };

    const handleUpload = async (file) => {
        addMessage("Iniciando o upload do arquivo para o bucket S3...");

        // Simular upload para S3
        try {
            await uploadFileToS3(file);
            addMessage(`Upload do arquivo ${file.name} concluÃ­do.`);
        } catch (error) {
            addMessage("Ocorreu um erro durante o upload. Tente novamente.");
            return;
        }

        addMessage(`Iniciando o processamento OCR para o arquivo ${file.name}...`);
        
        // Simular processamento OCR
        try {
            await processOCR(file.name);
            addMessage(`Processamento OCR concluÃ­do para o arquivo ${file.name}.`);
            addMessage(`O arquivo ${file.name} foi convertido com sucesso para TXT. FaÃ§a o download agora!`);
        } catch (error) {
            addMessage(`Erro ao processar o arquivo ${file.name}. Verifique se o arquivo Ã© um PDF vÃ¡lido.`);
        }
    };

    const uploadFileToS3 = (file) => {
        return new Promise((resolve) => {
            setTimeout(resolve, 2000); // Simulando um atraso de 2 segundos
        });
    };

    const processOCR = (filename) => {
        return new Promise((resolve) => {
            setTimeout(resolve, 3000); // Simulando um atraso de 3 segundos
        });
    };

    return (
        <div style={{ background: '#1e1e1e', color: '#ffffff', padding: '20px', borderRadius: '5px', height: '300px', overflowY: 'scroll' }}>
            <h3>Console Output</h3>
            <div>
                {messages.map((msg, index) => (
                    <div key={index}>{msg}</div>
                ))}
            </div>
            <button onClick={() => handleUpload({ name: 'example.pdf' })}>Iniciar Processamento</button>
        </div>
    );
};

export default ConsoleOutput;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\UploadForm.js:
import React, { useState } from 'react';

function UploadForm({ onUploadSuccess }) {
  const [file, setFile] = useState(null);  // Estado para armazenar o arquivo selecionado
  const [isUploading, setIsUploading] = useState(false);  // Estado para controlar o status de upload

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);  // Atualiza o estado com o arquivo selecionado
  };

  const handleUpload = async (event) => {
    event.preventDefault();

    if (!file) {
      alert('Por favor, selecione um arquivo para upload.');
      return;
    }

    const formData = new FormData();
    formData.append('file', file);

    setIsUploading(true);  // Inicia o processo de upload (mostrar indicador, desabilitar botÃ£o, etc.)

    try {
      const response = await fetch('http://127.0.0.1:5000/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erro ao fazer upload do arquivo.');
      }

      alert('Arquivo enviado com sucesso!');
      setFile(null);  // Limpa o arquivo selecionado apÃ³s o upload
      if (onUploadSuccess) {
        onUploadSuccess();  // Atualiza a lista de PDFs apÃ³s o upload
      }
    } catch (error) {
      alert(`Erro ao enviar arquivo: ${error.message}`);
    } finally {
      setIsUploading(false);  // Finaliza o processo de upload (remover indicador, habilitar botÃ£o, etc.)
    }
  };

  return (
    <form onSubmit={handleUpload}>
      <input
        type="file"
        accept=".pdf"  // Limita a seleÃ§Ã£o apenas para arquivos PDF
        onChange={handleFileChange}
        disabled={isUploading}  // Desabilita o input durante o upload
      />
      <button type="submit" disabled={isUploading}>
        {isUploading ? 'Enviando...' : 'Enviar PDF'}
      </button>
    </form>
  );
}

export default UploadForm;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\App.js:
import React, { useState, useEffect } from 'react'; 
import PDFList from './components/PDFList';         // Importa o componente para listar PDFs
import UploadForm from './components/UploadForm';     // Importa o componente de upload de arquivos
import PDFDetails from './components/PDFDetails';     // Importa o componente para mostrar detalhes do PDF
import DownloadText from './components/DownloadText'; // Importa o componente para download de texto (se aplicÃ¡vel)
import OCRButton from './components/OCRButton';       // Importa o componente para realizar OCR (se aplicÃ¡vel)
import Relatorio from './components/Relatorio';       // Importa o componente para gerar relatÃ³rios (se aplicÃ¡vel)
import './App.css';                                   // Importa os estilos

function App() {
  const [pdfs, setPdfs] = useState([]);              // Estado para armazenar a lista de PDFs
  const [selectedPdf, setSelectedPdf] = useState(null); // Estado para armazenar o PDF selecionado

  // FunÃ§Ã£o para buscar a lista de PDFs
  const fetchPDFs = async () => {
    try {
      const response = await fetch('http://localhost:5000/status'); // Faz a requisiÃ§Ã£o ao backend
      if (!response.ok) {
        throw new Error('Erro ao buscar o status dos PDFs'); // Lida com erros de resposta
      }
      const data = await response.json();
      // Transforma a resposta em uma lista de objetos com filename e status
      const pdfList = Object.keys(data).map(key => ({ filename: key, status: data[key].status }));
      setPdfs(pdfList); // Atualiza o estado com a lista de PDFs
    } catch (error) {
      console.error('Error fetching PDF status:', error); // Loga o erro no console
    }
  };

  // useEffect para buscar os PDFs ao carregar o componente
  useEffect(() => {
    fetchPDFs(); // Chama a funÃ§Ã£o fetchPDFs ao montar o componente
  }, []); // O array vazio faz com que o fetch ocorra apenas uma vez, ao montar o componente

  return (
    <div className="App">
      <h1>DigitalizaLaudos</h1> // TÃ­tulo do aplicativo
      <UploadForm onUploadSuccess={fetchPDFs} /> {/* FormulÃ¡rio de upload */}
      <PDFList pdfs={pdfs} onSelectPdf={setSelectedPdf} /> {/* Lista de PDFs */}
      {selectedPdf && (  // Exibe os detalhes do PDF selecionado
        <PDFDetails filename={selectedPdf.filename} />
      )}
      {/* Se vocÃª estiver utilizando DownloadText, OCRButton ou Relatorio, adicione-os aqui */}
      {/* <DownloadText /> */}
      {/* <OCRButton /> */}
      {/* <Relatorio /> */}
    </div>
  );
}

export default App;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\.gitignore:
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\package.json:
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

       (venv) PS C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend> python app.py
 * Serving Flask app 'app'
 * Debug mode: on
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 101-836-653
127.0.0.1 - - [06/Oct/2024 22:40:05] "GET /status HTTP/1.1" 200 -
127.0.0.1 - - [06/Oct/2024 22:40:05] "GET /status HTTP/1.1" 200 -
OCR processing error: An error occurred (DocumentTooLargeException) when calling the AnalyzeDocument operation: S3 object size 13974731 is more than the maximum limit 10485760
127.0.0.1 - - [06/Oct/2024 22:40:54] "POST /upload HTTP/1.1"