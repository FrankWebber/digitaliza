Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\app.py:
# Importações
import os
import logging
import sys
import traceback
from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from dotenv import load_dotenv
import boto3

# Adiciona o diretório pai ao sys.path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from debugger import log_error  # Importa a função de log

# Diretório para armazenar logs
log_directory = os.path.join(os.getcwd(), 'logs')
os.makedirs(log_directory, exist_ok=True)  # Cria o diretório se não existir

# Configurar logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(log_directory, "app.log")),  # Salva logs em logs/app.log
        logging.StreamHandler()  # Também exibe logs no console
    ]
)

logger = logging.getLogger(__name__)  # Cria um logger específico para este módulo

# Carregar variáveis de ambiente
load_dotenv()

# Configurar a aplicação Flask
app = Flask(__name__)
CORS(app)  # Habilita CORS para permitir requisições de outros domínios

# Middleware para registrar erros
@app.errorhandler(Exception)
def handle_error(error):
    log_error(str(error))
    logger.error('Internal Server Error: %s', str(error))  # Loga o erro
    return jsonify({'error': 'Internal server error'}), 500

# Configurar boto3 com as credenciais da AWS
s3_client = boto3.client(
    's3',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=os.getenv('AWS_REGION')
)

textract_client = boto3.client(
    'textract',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=os.getenv('AWS_REGION')
)

# Diretórios para armazenar PDFs e resultados
UPLOAD_FOLDER = os.path.join(os.getcwd(), 'pdfs')
RESULTS_FOLDER = os.path.join(os.getcwd(), 'results')

# Criar diretórios se não existirem
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULTS_FOLDER, exist_ok=True)

# Nome do bucket S3
S3_BUCKET_NAME = os.getenv('S3_BUCKET_NAME')

# Lista de PDFs monitorados e seus status
pdf_files = {}

# Defina um limite para o tamanho do arquivo
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB

@app.route('/upload', methods=['POST'])
def upload_pdf():
    try:
        if 'file' not in request.files:
            logger.error("No file part in the request.")
            return jsonify({'error': 'No file sent'}), 400

        file = request.files['file']
        if file.filename == '':
            logger.error("No selected file.")
            return jsonify({'error': 'No file selected'}), 400

        # Verifica se o arquivo é um PDF
        if file and file.filename.endswith('.pdf'):
            # Verifica o tamanho do arquivo
            if file.content_length > 10 * 1024 * 1024:  # 10 MB
                logger.error('File size exceeds the maximum limit of 10 MB.')
                return jsonify({'error': 'File size exceeds the maximum limit of 10 MB.'}), 400

            filepath = os.path.join(UPLOAD_FOLDER, file.filename)
            file.save(filepath)  # Salva o arquivo localmente

            # Fazer upload para S3
            try:
                s3_client.upload_file(filepath, S3_BUCKET_NAME, file.filename)
                logger.info('File uploaded to S3 successfully: %s', file.filename)  # Log de sucesso
            except Exception as e:
                logger.error('S3 upload error: %s', str(e))
                return jsonify({'error': 'Error uploading to S3'}), 500

            # Processar OCR
            response = textract_client.start_document_analysis(
                DocumentLocation={
                    'S3Object': {
                        'Bucket': S3_BUCKET_NAME,
                        'Name': file.filename
                    }
                },
                FeatureTypes=['TABLES', 'FORMS']
            )
            job_id = response['JobId']
            pdf_files[file.filename] = {'status': 'processing', 'job_id': job_id}
            return jsonify({'message': 'PDF uploaded and OCR started', 'jobId': job_id}), 200

        return jsonify({'error': 'Invalid file type, only PDFs are accepted'}), 400

    except Exception as e:
        logger.error('Error occurred in upload_pdf: %s', traceback.format_exc())
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/status/<filename>', methods=['GET'])
def get_status(filename):
    if filename not in pdf_files:
        return jsonify({'error': 'File not found'}), 404
    
    # Verificar status do job no Textract
    try:
        response = textract_client.get_document_analysis(JobId=pdf_files[filename]['job_id'])
        pdf_files[filename]['status'] = response['JobStatus']
    except Exception as e:
        logger.error('Error checking job status: %s', str(e))  # Loga o erro
        return jsonify({'error': 'Error checking job status'}), 500
    
    return jsonify(pdf_files[filename]), 200

@app.route('/status', methods=['GET'])
def get_all_status():
    return jsonify(pdf_files), 200

@app.route('/pdf/<filename>', methods=['GET'])
def get_pdf_data(filename):
    txt_file_path = os.path.join(RESULTS_FOLDER, f'{filename}.txt')
    if os.path.exists(txt_file_path):
        with open(txt_file_path, 'r') as file:
            return jsonify({'data': file.read()}), 200
    return jsonify({'error': 'File not found'}), 404

@app.route('/pdfs/<path:filename>', methods=['GET'])
def serve_pdf(filename):
    try:
        return send_from_directory(UPLOAD_FOLDER, filename)
    except Exception as e:
        logger.error('Error serving PDF: %s', str(e))  # Loga o erro
        return jsonify({'error': str(e)}), 404

@app.route('/log-error', methods=['POST'])
def log_test_error():
    try:
        data = request.json
        error_message = data.get('error', 'No error message provided')
        logger.error('Test Error: %s', error_message)  # Loga a mensagem de erro
        return jsonify({'message': 'Error logged successfully'}), 200
    except Exception as e:
        logger.error('Error logging test error: %s', str(e))
        return jsonify({'message': 'Failed to log error'}), 500

@app.route('/ocr-status/<job_id>', methods=['GET'])
def check_ocr_status(job_id):
    try:
        response = textract_client.get_document_analysis(JobId=job_id)
        
        # Verifica se o OCR foi concluído
        if response['JobStatus'] == 'SUCCEEDED':
            return jsonify({'status': 'SUCCEEDED', 'results': response}), 200
        elif response['JobStatus'] == 'FAILED':
            return jsonify({'status': 'FAILED'}), 500
        else:
            return jsonify({'status': 'IN_PROGRESS'}), 200
    except Exception as e:
        logger.error('Erro ao verificar status do OCR: %s', str(e))
        return jsonify({'error': 'Erro ao verificar status do OCR'}), 500

def extract_text_and_save(response, output_txt_path):
    with open(output_txt_path, 'w', encoding='utf-8') as txt_file:
        for item in response.get('Blocks', []):
            if item['BlockType'] == 'LINE':
                txt_file.write(item['Text'] + '\n')

@app.route('/logs', methods=['GET'])
def get_logs():
    log_file_path = os.path.join(log_directory, 'app.log')
    try:
        with open(log_file_path, 'r') as log_file:
            logs = log_file.readlines()[-50:]  # Pega as últimas 50 linhas do log
        return jsonify({'logs': logs}), 200
    except Exception as e:
        logger.error('Error reading log file: %s', str(e))
        return jsonify({'error': 'Could not read log file'}), 500

@app.route('/ocr-status/<job_id>', methods=['GET'])
def check_ocr_status(job_id):
    try:
        response = textract_client.get_document_analysis(JobId=job_id)
        
        # Verifica se o OCR foi concluído
        if response['JobStatus'] == 'SUCCEEDED':
            # Salvar texto extraído
            output_txt_path = os.path.join(RESULTS_FOLDER, f'{job_id}.txt')  # Salva o arquivo com o job_id
            extract_text_and_save(response, output_txt_path)  # Chama a função para extrair texto
            
            return jsonify({'status': 'SUCCEEDED', 'results': response}), 200
        elif response['JobStatus'] == 'FAILED':
            return jsonify({'status': 'FAILED'}), 500
        else:
            return jsonify({'status': 'IN_PROGRESS'}), 200
    except Exception as e:
        logger.error('Erro ao verificar status do OCR: %s', str(e))
        return jsonify({'error': 'Erro ao verificar status do OCR'}), 500

def extract_text_and_save(response, output_txt_path):
    with open(output_txt_path, 'w', encoding='utf-8') as txt_file:
        for item in response.get('Blocks', []):
            if item['BlockType'] == 'LINE':
                txt_file.write(item['Text'] + '\n')



if __name__ == '__main__':
    app.run(debug=True, port=5000)


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\ocr_processor.py:
import boto3
import time
from dotenv import load_dotenv
import os

# Carrega as variáveis do arquivo .env
load_dotenv()

# Acessando as variáveis de ambiente
AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
AWS_REGION = os.getenv('AWS_REGION')
S3_BUCKET_NAME = os.getenv('S3_BUCKET_NAME')

# Inicializa o cliente do Textract
textract = boto3.client('textract', aws_access_key_id=AWS_ACCESS_KEY_ID, 
                         aws_secret_access_key=AWS_SECRET_ACCESS_KEY, 
                         region_name=AWS_REGION)

def process_document(bucket_name, document_name):
    # Inicia o processamento do documento
    response = textract.start_document_text_detection(
        DocumentLocation={'S3Object': {'Bucket': bucket_name, 'Name': document_name}}
    )

    # Salvar o JobId para verificar o status do processamento
    job_id = response['JobId']
    
    # Aguardar até que o Textract conclua o processamento
    while True:
        response = textract.get_document_text_detection(JobId=job_id)
        
        if 'JobStatus' in response and response['JobStatus'] in ['SUCCEEDED', 'FAILED']:
            break
        
        print("Aguardando...")  # Mensagem de status
        time.sleep(5)  # Aguardar 5 segundos entre as verificações
    
    return response

def extract_text_and_save(response, output_txt_path):
    with open(output_txt_path, 'w', encoding='utf-8') as txt_file:
        for item in response.get('Blocks', []):
            if item['BlockType'] == 'LINE':
                txt_file.write(item['Text'] + '\n')

def check_ocr_status(job_id):
    textract = boto3.client('textract', aws_access_key_id=AWS_ACCESS_KEY_ID, 
                             aws_secret_access_key=AWS_SECRET_ACCESS_KEY, 
                             region_name=AWS_REGION)

    # Chama a API para verificar o status do trabalho
    response = textract.get_document_analysis(JobId=job_id)

    # Lógica para tratar os diferentes estados do job
    if response['JobStatus'] == 'SUCCEEDED':
        return response
    elif response['JobStatus'] in ['FAILED', 'PARTIAL_SUCCESS']:
        raise Exception(f"O processamento falhou com o status: {response['JobStatus']}")
    else:
        return None  # Retorna None se o job ainda está em processamento

# Uso da função
if __name__ == "__main__":
    # Defina o nome do bucket e o arquivo PDF que foi enviado
    bucket_name = S3_BUCKET_NAME  # Obtém o nome do bucket do arquivo .env
    uploaded_pdf = 'example.pdf'  # Nome do arquivo PDF que foi enviado

    # Processa o documento
    response = process_document(bucket_name, uploaded_pdf)

    # Salvar texto extraído
    output_txt_path = r"C:\Users\Frank Webber\Documents\GitHub\digita-liza\results\resultado.txt"
    extract_text_and_save(response, output_txt_path)

    print("Texto extraído salvo em:", output_txt_path)


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\DownloadText.js:
import React from 'react';

const DownloadText = ({ text, filename }) => {
  const downloadFile = () => {
    const blob = new Blob([text], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${filename}.txt`;
    link.click();
  };

  return (
    <div>
      <button onClick={downloadFile} disabled={!text}>
        Baixar Texto Extraído
      </button>
    </div>
  );
};

export default DownloadText;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\OCRButton.js:
import React, { useState } from 'react';

const OCRButton = ({ file, onOCR }) => {
  const [jobId, setJobId] = useState(null);
  const [status, setStatus] = useState(null);

  const handleClick = async () => {
    console.log('Arquivo enviado:', file); // Aqui é onde você adiciona o log

    try {
      const formData = new FormData();
      formData.append('file', file);

      const startResponse = await fetch('http://127.0.0.1:5000/upload', {
        method: 'POST',
        body: formData,
      });

      if (!startResponse.ok) {
        throw new Error('Erro ao iniciar o OCR');
      }

      const { jobId: newJobId } = await startResponse.json();
      setJobId(newJobId);

      // Verifica o status do OCR periodicamente
      const statusInterval = setInterval(async () => {
        const statusResponse = await fetch(`http://127.0.0.1:5000/ocr-status/${newJobId}`, {
          method: 'GET',
        });

        if (!statusResponse.ok) {
          throw new Error('Erro ao verificar status do OCR');
        }

        const { status, results } = await statusResponse.json();
        setStatus(status);

        if (status === 'SUCCEEDED') {
          clearInterval(statusInterval);  // Para de verificar o status
          onOCR(results);  // Retorna os resultados do OCR
        }
      }, 5000);  // Verifica a cada 5 segundos
    } catch (error) {
      console.error('Erro ao processar OCR:', error);
    }
  };

  return (
    <div>
      <button onClick={handleClick}>
        Processar OCR
      </button>
      {status && <p>Status do OCR: {status}</p>}
    </div>
  );
};

export default OCRButton;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\Relatorio.js:
import React, { useState, useEffect } from 'react';

const Relatorio = () => {
  const [logs, setLogs] = useState([]);
  const [loading, setLoading] = useState(true);

  // Função para buscar logs do backend
  const fetchLogs = async () => {
    setLoading(true);
    try {
      const response = await fetch('http://127.0.0.1:5000/logs'); // Endpoint que você precisa implementar no backend
      if (!response.ok) {
        throw new Error('Erro ao buscar logs do servidor');
      }
      const data = await response.json();
      setLogs(data.logs || []);
    } catch (error) {
      console.error('Erro ao buscar logs:', error);
      setLogs(['Erro ao buscar logs']);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchLogs();
    const interval = setInterval(fetchLogs, 5000); // Atualiza os logs a cada 5 segundos
    return () => clearInterval(interval);
  }, []);

  return (
    <div>
      <h3>Relatório de Atividades do Backend</h3>
      {loading ? (
        <p>Carregando logs...</p>
      ) : (
        <ul>
          {logs.map((log, index) => (
            <li key={index}>{log}</li>
          ))}
        </ul>
      )}
    </div>
  );
};

export default Relatorio;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\UploadForm.js:
import React, { useState } from 'react';

function UploadForm({ onUploadSuccess, setJobId, setFilename }) {
  const [file, setFile] = useState(null);
  const [isUploading, setIsUploading] = useState(false);

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);  // Atualiza o estado com o arquivo selecionado
  };

  const handleUpload = async (event) => {
    event.preventDefault();

    if (!file) {
      alert('Por favor, selecione um arquivo para upload.');
      return;
    }

    const formData = new FormData();
    formData.append('file', file);  // Adiciona o arquivo ao FormData

    setIsUploading(true);  // Inicia o processo de upload

    try {
      const response = await fetch('http://127.0.0.1:5000/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erro ao fazer upload do arquivo.');
      }

      const data = await response.json();
      alert('Arquivo enviado com sucesso!');
      setJobId(data.jobId);  // Atualiza o jobId
      setFilename(file.name); // Atualiza o filename
      setFile(null);  // Limpa o arquivo selecionado após o upload
      if (onUploadSuccess) {
        onUploadSuccess();  // Atualiza a lista de PDFs após o upload
      }
    } catch (error) {
      alert(`Erro ao enviar arquivo: ${error.message}`);  // Mensagem de erro
    } finally {
      setIsUploading(false);  // Finaliza o processo de upload
    }
  };

  return (
    <form onSubmit={handleUpload}>
      <input
        type="file"
        accept=".pdf"  // Limita a seleção apenas para arquivos PDF
        onChange={handleFileChange}
        disabled={isUploading}  // Desabilita o input durante o upload
      />
      <button type="submit" disabled={isUploading}>
        {isUploading ? 'Enviando...' : 'Enviar PDF'}
      </button>
    </form>
  );
}

export default UploadForm;


Conteúdo de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\App.js:
// src/App.js
import React, { useState, useEffect } from 'react';
import PDFList from './components/PDFList';
import UploadForm from './components/UploadForm';
import PDFDetails from './components/PDFDetails';
import ConsoleOutput from './components/ConsoleOutput'; // Importa o ConsoleOutput
import './App.css';

function App() {
  const [pdfs, setPdfs] = useState([]);
  const [selectedPdf, setSelectedPdf] = useState(null);
  const [jobId, setJobId] = useState(null);
  const [filename, setFilename] = useState(null);

  const fetchPDFs = async () => {
    try {
      const response = await fetch('http://localhost:5000/status');
      if (!response.ok) {
        throw new Error('Erro ao buscar o status dos PDFs');
      }
      const data = await response.json();
      const pdfList = Object.keys(data).map(key => ({ filename: key, status: data[key].status }));
      setPdfs(pdfList);
    } catch (error) {
      console.error('Error fetching PDF status:', error);
      alert("Ocorreu um erro ao buscar o status dos PDFs. Verifique se o backend está funcionando.");
    }
  };

  useEffect(() => {
    fetchPDFs();
  }, []);

  return (
    <div className="App">
      <h1>DigitalizaLaudos</h1>
      <UploadForm onUploadSuccess={fetchPDFs} setJobId={setJobId} setFilename={setFilename} />
      <PDFList pdfs={pdfs} onSelectPdf={setSelectedPdf} />
      {selectedPdf && <PDFDetails filename={selectedPdf.filename} />}
      <ConsoleOutput jobId={jobId} filename={filename} /> {/* Adiciona o ConsoleOutput */}
    </div>
  );
}

export default App;


