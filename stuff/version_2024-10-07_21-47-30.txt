Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\package.json:
{
  "dependencies": {
    "aws-sdk": "^2.1691.0",
    "axios": "^1.7.7",
    "cors": "^2.8.5"
  }
}


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\.gitignore:
# Ignorar o ambiente virtual do Python
venv/

# Ignorar pastas de resultados e PDFs
backend/pdfs/
backend/results/

# Ignorar arquivos de configura√ß√£o do sistema
.DS_Store
Thumbs.db

# Ignorar arquivos de log
*.log

# Ignorar arquivos de cache do Node.js
node_modules/
npm-debug.log
yarn-error.log

# Ignorar arquivos do sistema de controle de vers√£o
.git/


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\LEIAME.txt:
# Digita-Lisa

O **Digita-Lisa** √© um sistema de digitaliza√ß√£o e extra√ß√£o de informa√ß√µes automatizadas de documentos com integra√ß√£o ao Amazon Textract, projetado para auxiliar a Junta M√©dica Pericial do Amazonas a processar laudos m√©dicos e outros documentos.

## Funcionalidades

- Extra√ß√£o de texto, tabelas e formul√°rios de documentos digitalizados.
- Suporte a m√∫ltiplas p√°ginas e diferentes tipos de documentos (PDF, imagens, etc).
- Automa√ß√£o do reconhecimento de manuscritos, assinaturas e campos de valor-chave.
- Integra√ß√£o com o Amazon S3 para armazenamento de documentos processados.

## Pr√©-requisitos

- Conta AWS ativa com permiss√µes para utilizar o **Amazon Textract** e **Amazon S3**.
- Node.js e npm instalados localmente.

## Instala√ß√£o

1. Clone o reposit√≥rio:

    ```bash
    git clone https://github.com/seuprojeto/digita-lisa.git
    ```

2. Navegue at√© o diret√≥rio do projeto:

    ```bash
    cd digita-lisa
    ```

3. Instale as depend√™ncias do projeto:

    ```bash
    npm install
    ```

4. Configure as vari√°veis de ambiente no arquivo `.env` (ver instru√ß√µes abaixo).

5. Execute o projeto localmente:

    ```bash
    npm start
    ```

## Configura√ß√£o do .env

O arquivo `.env` precisa ser configurado com as credenciais AWS e informa√ß√µes do bucket S3. Veja a se√ß√£o de vari√°veis de ambiente para mais detalhes.

### Exemplo de configura√ß√£o `.env`:

```bash
AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2
S3_BUCKET_NAME=digita-lisa


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\.env:
# Credenciais AWS
AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2

# Nome do bucket S3
S3_BUCKET_NAME=digita-lisa

# Par√¢metros do Amazon Textract
TEXTRACT_OUTPUT_BUCKET=digita-lisa

# Configura√ß√µes adicionais
TEXTRACT_MAX_RETRIES=3
TEXTRACT_TIMEOUT=60000

# Par√¢metros de seguran√ßa (Token JWT ou outro segredo)
JWT_SECRET=mySuperSecretToken


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\app.py:
# Importa√ß√µes
import os
import logging
import sys
import traceback
from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from dotenv import load_dotenv
import boto3

# Adiciona o diret√≥rio pai ao sys.path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from debugger import log_error  # Importa a fun√ß√£o de log

# Diret√≥rio para armazenar logs
log_directory = os.path.join(os.getcwd(), 'logs')
os.makedirs(log_directory, exist_ok=True)  # Cria o diret√≥rio se n√£o existir

# Configurar logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(log_directory, "app.log")),  # Salva logs em logs/app.log
        logging.StreamHandler()  # Tamb√©m exibe logs no console
    ]
)

logger = logging.getLogger(__name__)  # Cria um logger espec√≠fico para este m√≥dulo

# Carregar vari√°veis de ambiente
load_dotenv()

# Configurar a aplica√ß√£o Flask
app = Flask(__name__)
CORS(app)

# Middleware para registrar erros
@app.errorhandler(Exception)
def handle_error(error):
    log_error(str(error))
    logger.error('Internal Server Error: %s', str(error))  # Loga o erro
    return jsonify({'error': 'Internal server error'}), 500

# Configurar boto3 com as credenciais da AWS
s3_client = boto3.client(
    's3',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=os.getenv('AWS_REGION')
)

textract_client = boto3.client(
    'textract',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=os.getenv('AWS_REGION')
)

# Diret√≥rios para armazenar PDFs e resultados
UPLOAD_FOLDER = os.path.join(os.getcwd(), 'pdfs')
RESULTS_FOLDER = os.path.join(os.getcwd(), 'results')

# Criar diret√≥rios se n√£o existirem
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULTS_FOLDER, exist_ok=True)

# Nome do bucket S3
S3_BUCKET_NAME = os.getenv('S3_BUCKET_NAME')

# Lista de PDFs monitorados e seus status
pdf_files = {}

# Defina um limite para o tamanho do arquivo
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB

@app.route('/upload', methods=['POST'])
def upload_pdf():
    try:
        if 'file' not in request.files:
            return jsonify({'error': 'No file sent'}), 400

        file = request.files['file']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400

        if file and file.filename.endswith('.pdf'):
            if file.content_length > 10 * 1024 * 1024:
                return jsonify({'error': 'File size exceeds the maximum limit of 10 MB.'}), 400
            
            filepath = os.path.join(UPLOAD_FOLDER, file.filename)
            file.save(filepath)

            # Fazer upload para S3
            try:
                s3_client.upload_file(filepath, S3_BUCKET_NAME, file.filename)
            except Exception as e:
                logger.error('S3 upload error: %s', str(e))
                return jsonify({'error': 'Error uploading to S3'}), 500

            # Processar OCR no PDF enviado
            try:
                response = textract_client.start_document_analysis(
                    DocumentLocation={
                        'S3Object': {
                            'Bucket': S3_BUCKET_NAME,
                            'Name': file.filename
                        }
                    },
                    FeatureTypes=['TABLES', 'FORMS']
                )
                job_id = response['JobId']
                pdf_files[file.filename] = {'status': 'processing', 'job_id': job_id}
            except textract_client.exceptions.DocumentTooLargeException:
                return jsonify({'error': 'The document is too large for processing. Please consider reducing the file size.'}), 400
            except Exception as e:
                logger.error('OCR processing error: %s', str(e))
                return jsonify({'error': 'Error processing OCR'}), 500

            return jsonify({'message': 'PDF uploaded and OCR started', 'file': file.filename}), 200

        return jsonify({'error': 'Invalid file type, only PDFs are accepted'}), 400

    except Exception as e:
        logger.error('Error occurred in upload_pdf: %s', traceback.format_exc())  # Loga o erro
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/status/<filename>', methods=['GET'])
def get_status(filename):
    if filename not in pdf_files:
        return jsonify({'error': 'File not found'}), 404
    
    # Verificar status do job no Textract
    try:
        response = textract_client.get_document_analysis(JobId=pdf_files[filename]['job_id'])
        pdf_files[filename]['status'] = response['JobStatus']
    except Exception as e:
        logger.error('Error checking job status: %s', str(e))  # Loga o erro
        return jsonify({'error': 'Error checking job status'}), 500
    
    return jsonify(pdf_files[filename]), 200

@app.route('/status', methods=['GET'])
def get_all_status():
    return jsonify(pdf_files), 200

@app.route('/pdf/<filename>', methods=['GET'])
def get_pdf_data(filename):
    txt_file_path = os.path.join(RESULTS_FOLDER, f'{filename}.txt')
    if os.path.exists(txt_file_path):
        with open(txt_file_path, 'r') as file:
            return jsonify({'data': file.read()}), 200
    return jsonify({'error': 'File not found'}), 404

@app.route('/pdfs/<path:filename>', methods=['GET'])
def serve_pdf(filename):
    try:
        return send_from_directory(UPLOAD_FOLDER, filename)
    except Exception as e:
        logger.error('Error serving PDF: %s', str(e))  # Loga o erro
        return jsonify({'error': str(e)}), 404

@app.route('/log-error', methods=['POST'])
def log_test_error():
    try:
        data = request.json
        error_message = data.get('error', 'No error message provided')
        logger.error('Test Error: %s', error_message)  # Loga a mensagem de erro
        return jsonify({'message': 'Error logged successfully'}), 200
    except Exception as e:
        logger.error('Error logging test error: %s', str(e))
        return jsonify({'message': 'Failed to log error'}), 500

if __name__ == '__main__':
    app.run(debug=True, port=5000)


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\ocr_processor.py:
import boto3
import time
from dotenv import load_dotenv
import os

# Carrega as vari√°veis do arquivo .env
load_dotenv()

# Acessando as vari√°veis de ambiente
AWS_ACCESS_KEY_ID = os.getenv('AWS_ACCESS_KEY_ID')
AWS_SECRET_ACCESS_KEY = os.getenv('AWS_SECRET_ACCESS_KEY')
AWS_REGION = os.getenv('AWS_REGION')
S3_BUCKET_NAME = os.getenv('S3_BUCKET_NAME')

# Inicializa o cliente do Textract
textract = boto3.client('textract', aws_access_key_id=AWS_ACCESS_KEY_ID, 
                         aws_secret_access_key=AWS_SECRET_ACCESS_KEY, 
                         region_name=AWS_REGION)

def process_document(bucket_name, document_name):
    # Inicia o processamento do documento
    response = textract.start_document_text_detection(
        DocumentLocation={'S3Object': {'Bucket': bucket_name, 'Name': document_name}}
    )

    # Salvar o JobId para verificar o status do processamento
    job_id = response['JobId']
    
    # Aguardar at√© que o Textract conclua o processamento
    while True:
        response = textract.get_document_text_detection(JobId=job_id)
        
        if 'JobStatus' in response and response['JobStatus'] in ['SUCCEEDED', 'FAILED']:
            break
        
        print("Aguardando...")  # Mensagem de status
        time.sleep(5)  # Aguardar 5 segundos entre as verifica√ß√µes
    
    return response

def extract_text_and_save(response, output_txt_path):
    with open(output_txt_path, 'w', encoding='utf-8') as txt_file:
        for item in response.get('Blocks', []):
            if item['BlockType'] == 'LINE':
                txt_file.write(item['Text'] + '\n')

def check_ocr_status(job_id):
    textract = boto3.client('textract', aws_access_key_id=AWS_ACCESS_KEY_ID, 
                             aws_secret_access_key=AWS_SECRET_ACCESS_KEY, 
                             region_name=AWS_REGION)

    # Chama a API para verificar o status do trabalho
    response = textract.get_document_analysis(JobId=job_id)

    # L√≥gica para tratar os diferentes estados do job
    if response['JobStatus'] == 'SUCCEEDED':
        return response
    elif response['JobStatus'] in ['FAILED', 'PARTIAL_SUCCESS']:
        raise Exception(f"O processamento falhou com o status: {response['JobStatus']}")
    else:
        return None  # Retorna None se o job ainda est√° em processamento

# Uso da fun√ß√£o
if __name__ == "__main__":
    # Defina o nome do bucket e o arquivo PDF que foi enviado
    bucket_name = S3_BUCKET_NAME  # Obt√©m o nome do bucket do arquivo .env
    uploaded_pdf = 'example.pdf'  # Nome do arquivo PDF que foi enviado

    # Processa o documento
    response = process_document(bucket_name, uploaded_pdf)

    # Salvar texto extra√≠do
    output_txt_path = r"C:\Users\Frank Webber\Documents\GitHub\digita-liza\results\resultado.txt"
    extract_text_and_save(response, output_txt_path)

    print("Texto extra√≠do salvo em:", output_txt_path)


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\requirements.txt:
Flask==2.3.2
Werkzeug==2.3.4
requests==2.28.2
boto3==1.26.7
flask_cors==3.0.10
python-dotenv==1.0.0


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\DownloadText.js:
import React from 'react';

const DownloadText = ({ text, filename }) => {
  const downloadFile = () => {
    const blob = new Blob([text], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${filename}.txt`;
    link.click();
  };

  return (
    <div>
      <button onClick={downloadFile} disabled={!text}>
        Baixar Texto Extra√≠do
      </button>
    </div>
  );
};

export default DownloadText;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\OCRButton.js:
import React from 'react';

const OCRButton = ({ filename, onOCR }) => {
  const handleClick = async () => {
    try {
      const response = await fetch(`http://127.0.0.1:5000/pdf/${filename}`, {
        method: 'GET',
      });

      if (!response.ok) {
        throw new Error('Erro ao solicitar OCR');
      }

      const data = await response.json();
      console.log(data);
      onOCR(data); // Chama a fun√ß√£o onOCR passada como prop
    } catch (error) {
      console.error('Erro ao processar OCR:', error);
    }
  };

  return (
    <button onClick={handleClick}>
      Processar OCR
    </button>
  );
};

export default OCRButton;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\PDFDetails.js:
import React, { useState } from 'react';

const PDFDetails = ({ filename }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/pdf/${filename}`);
      const result = await response.json();
      if (result.data) {
        setData(result.data);
      } else {
        setData("Nenhum texto extra√≠do encontrado.");
      }
    } catch (error) {
      console.error('Erro ao buscar dados:', error);
      setData("Erro ao buscar dados.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={fetchData} disabled={loading}>
        {loading ? 'Carregando...' : 'Ver OCR'}
      </button>
      {data && <pre>{data}</pre>}
    </div>
  );
};

export default PDFDetails;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\PDFList.js:
import React from 'react';
import OCRButton from './OCRButton'; // Importa o OCRButton para cada PDF

const PDFList = ({ pdfs, onSelectPdf }) => {
  return (
    <div>
      <h2>Lista de PDFs Digitalizados</h2>
      <ul>
        {pdfs.map((pdf, index) => (
          <li key={index}>
            <p>{pdf.filename} - {pdf.status}</p>
            <OCRButton filename={pdf.filename} onOCR={onSelectPdf} />
          </li>
        ))}
      </ul>
    </div>
  );
};

export default PDFList;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\Relatorio.js:
import React, { useState } from 'react';

const ConsoleOutput = () => {
    const [messages, setMessages] = useState([]);

    const addMessage = (newMessage) => {
        setMessages((prevMessages) => [...prevMessages, newMessage]);
    };

    const handleUpload = async (file) => {
        addMessage("Iniciando o upload do arquivo para o bucket S3...");

        // Simular upload para S3
        try {
            await uploadFileToS3(file);
            addMessage(`Upload do arquivo ${file.name} conclu√≠do.`);
        } catch (error) {
            addMessage("Ocorreu um erro durante o upload. Tente novamente.");
            return;
        }

        addMessage(`Iniciando o processamento OCR para o arquivo ${file.name}...`);
        
        // Simular processamento OCR
        try {
            await processOCR(file.name);
            addMessage(`Processamento OCR conclu√≠do para o arquivo ${file.name}.`);
            addMessage(`O arquivo ${file.name} foi convertido com sucesso para TXT. Fa√ßa o download agora!`);
        } catch (error) {
            addMessage(`Erro ao processar o arquivo ${file.name}. Verifique se o arquivo √© um PDF v√°lido.`);
        }
    };

    const uploadFileToS3 = (file) => {
        return new Promise((resolve) => {
            setTimeout(resolve, 2000); // Simulando um atraso de 2 segundos
        });
    };

    const processOCR = (filename) => {
        return new Promise((resolve) => {
            setTimeout(resolve, 3000); // Simulando um atraso de 3 segundos
        });
    };

    return (
        <div style={{ background: '#1e1e1e', color: '#ffffff', padding: '20px', borderRadius: '5px', height: '300px', overflowY: 'scroll' }}>
            <h3>Console Output</h3>
            <div>
                {messages.map((msg, index) => (
                    <div key={index}>{msg}</div>
                ))}
            </div>
            <button onClick={() => handleUpload({ name: 'example.pdf' })}>Iniciar Processamento</button>
        </div>
    );
};

export default ConsoleOutput;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\UploadForm.js:
import React, { useState } from 'react';

function UploadForm({ onUploadSuccess }) {
  const [file, setFile] = useState(null);  // Estado para armazenar o arquivo selecionado
  const [isUploading, setIsUploading] = useState(false);  // Estado para controlar o status de upload

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);  // Atualiza o estado com o arquivo selecionado
  };

  const handleUpload = async (event) => {
    event.preventDefault();

    if (!file) {
      alert('Por favor, selecione um arquivo para upload.');
      return;
    }

    const formData = new FormData();
    formData.append('file', file);

    setIsUploading(true);  // Inicia o processo de upload (mostrar indicador, desabilitar bot√£o, etc.)

    try {
      const response = await fetch('http://127.0.0.1:5000/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erro ao fazer upload do arquivo.');
      }

      alert('Arquivo enviado com sucesso!');
      setFile(null);  // Limpa o arquivo selecionado ap√≥s o upload
      if (onUploadSuccess) {
        onUploadSuccess();  // Atualiza a lista de PDFs ap√≥s o upload
      }
    } catch (error) {
      alert(`Erro ao enviar arquivo: ${error.message}`);
    } finally {
      setIsUploading(false);  // Finaliza o processo de upload (remover indicador, habilitar bot√£o, etc.)
    }
  };

  return (
    <form onSubmit={handleUpload}>
      <input
        type="file"
        accept=".pdf"  // Limita a sele√ß√£o apenas para arquivos PDF
        onChange={handleFileChange}
        disabled={isUploading}  // Desabilita o input durante o upload
      />
      <button type="submit" disabled={isUploading}>
        {isUploading ? 'Enviando...' : 'Enviar PDF'}
      </button>
    </form>
  );
}

export default UploadForm;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\App.js:
import React, { useState, useEffect } from 'react';
import PDFList from './components/PDFList';
import UploadForm from './components/UploadForm';
import PDFDetails from './components/PDFDetails';
import LogErrorButton from './components/LogErrorButton'; // Importa o bot√£o de log de erro
import './App.css';

function App() {
    const [pdfs, setPdfs] = useState([]);
    const [selectedPdf, setSelectedPdf] = useState(null);

    // Fun√ß√£o para buscar a lista de PDFs
    const fetchPDFs = async () => {
        try {
            const response = await fetch('http://localhost:5000/status');
            if (!response.ok) {
                throw new Error('Erro ao buscar o status dos PDFs');
            }
            const data = await response.json();
            const pdfList = Object.keys(data).map(key => ({ filename: key, status: data[key].status }));
            setPdfs(pdfList);
        } catch (error) {
            console.error('Error fetching PDF status:', error);
            alert("Ocorreu um erro ao buscar o status dos PDFs. Verifique se o backend est√° funcionando.");
        }
    };

    useEffect(() => {
        fetchPDFs();
    }, []);

    return (
        <div className="App">
            <h1>DigitalizaLaudos</h1>
            <UploadForm onUploadSuccess={fetchPDFs} />
            <PDFList pdfs={pdfs} onSelectPdf={setSelectedPdf} />
            {selectedPdf && <PDFDetails filename={selectedPdf.filename} />}
            <LogErrorButton /> {/* Adiciona o bot√£o de log de erro */}
        </div>
    );
}

export default App;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\.gitignore:
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\package.json:
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "debug": "^4.3.7",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11"
  }
}


