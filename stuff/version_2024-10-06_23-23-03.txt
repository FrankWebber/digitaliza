Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\package.json:
{
  "dependencies": {
    "aws-sdk": "^2.1691.0",
    "axios": "^1.7.7",
    "cors": "^2.8.5"
  }
}


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\.gitignore:
# Ignorar o ambiente virtual do Python
venv/

# Ignorar pastas de resultados e PDFs
backend/pdfs/
backend/results/

# Ignorar arquivos de configura√ß√£o do sistema
.DS_Store
Thumbs.db

# Ignorar arquivos de log
*.log

# Ignorar arquivos de cache do Node.js
node_modules/
npm-debug.log
yarn-error.log

# Ignorar arquivos do sistema de controle de vers√£o
.git/


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\LEIAME.txt:
# Digita-Lisa

O **Digita-Lisa** √© um sistema de digitaliza√ß√£o e extra√ß√£o de informa√ß√µes automatizadas de documentos com integra√ß√£o ao Amazon Textract, projetado para auxiliar a Junta M√©dica Pericial do Amazonas a processar laudos m√©dicos e outros documentos.

## Funcionalidades

- Extra√ß√£o de texto, tabelas e formul√°rios de documentos digitalizados.
- Suporte a m√∫ltiplas p√°ginas e diferentes tipos de documentos (PDF, imagens, etc).
- Automa√ß√£o do reconhecimento de manuscritos, assinaturas e campos de valor-chave.
- Integra√ß√£o com o Amazon S3 para armazenamento de documentos processados.

## Pr√©-requisitos

- Conta AWS ativa com permiss√µes para utilizar o **Amazon Textract** e **Amazon S3**.
- Node.js e npm instalados localmente.

## Instala√ß√£o

1. Clone o reposit√≥rio:

    ```bash
    git clone https://github.com/seuprojeto/digita-lisa.git
    ```

2. Navegue at√© o diret√≥rio do projeto:

    ```bash
    cd digita-lisa
    ```

3. Instale as depend√™ncias do projeto:

    ```bash
    npm install
    ```

4. Configure as vari√°veis de ambiente no arquivo `.env` (ver instru√ß√µes abaixo).

5. Execute o projeto localmente:

    ```bash
    npm start
    ```

## Configura√ß√£o do .env

O arquivo `.env` precisa ser configurado com as credenciais AWS e informa√ß√µes do bucket S3. Veja a se√ß√£o de vari√°veis de ambiente para mais detalhes.

### Exemplo de configura√ß√£o `.env`:

```bash
AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2
S3_BUCKET_NAME=digita-lisa


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\.env:
# Credenciais AWS
AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2

# Nome do bucket S3
S3_BUCKET_NAME=digita-lisa

# Par√¢metros do Amazon Textract
TEXTRACT_OUTPUT_BUCKET=digita-lisa

# Configura√ß√µes adicionais
TEXTRACT_MAX_RETRIES=3
TEXTRACT_TIMEOUT=60000

# Par√¢metros de seguran√ßa (Token JWT ou outro segredo)
JWT_SECRET=mySuperSecretToken


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\app.py:
from flask import Flask, jsonify, request
from flask_cors import CORS
import os
import boto3
import traceback
from dotenv import load_dotenv

# Carregar vari√°veis de ambiente
load_dotenv()

# Configurar a aplica√ß√£o Flask
app = Flask(__name__)
CORS(app)

# Configurar boto3 com as credenciais da AWS
s3_client = boto3.client(
    's3',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=os.getenv('AWS_REGION')
)

textract_client = boto3.client(
    'textract',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY'),
    region_name=os.getenv('AWS_REGION')
)

# Diret√≥rios para armazenar PDFs e resultados
UPLOAD_FOLDER = os.path.join(os.getcwd(), 'pdfs')
RESULTS_FOLDER = os.path.join(os.getcwd(), 'results')

# Criar diret√≥rios se n√£o existirem
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULTS_FOLDER, exist_ok=True)

# Nome do bucket S3
S3_BUCKET_NAME = os.getenv('S3_BUCKET_NAME')

# Lista de PDFs monitorados e seus status
pdf_files = {}

# Defina um limite para o tamanho do arquivo (opcional)
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB

@app.route('/upload', methods=['POST'])
def upload_pdf():
    try:
        if 'file' not in request.files:
            return jsonify({'error': 'No file sent'}), 400

        file = request.files['file']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400

        if file and file.filename.endswith('.pdf'):
            # Verificar se o tamanho do arquivo √© maior que 10 MB
            if file.content_length > 10 * 1024 * 1024:
                return jsonify({'error': 'File size exceeds the maximum limit of 10 MB.'}), 400
            
            filepath = os.path.join(UPLOAD_FOLDER, file.filename)
            file.save(filepath)

            # Fazer upload para S3
            try:
                s3_client.upload_file(filepath, S3_BUCKET_NAME, file.filename)
            except Exception as e:
                print(f"S3 upload error: {e}")
                return jsonify({'error': 'Error uploading to S3'}), 500

            # Processar OCR no PDF enviado
            try:
                response = textract_client.start_document_analysis(
                    DocumentLocation={
                        'S3Object': {
                            'Bucket': S3_BUCKET_NAME,
                            'Name': file.filename
                        }
                    },
                    FeatureTypes=['TABLES', 'FORMS']
                )
                job_id = response['JobId']
                pdf_files[file.filename] = {'status': 'processing', 'job_id': job_id}
            except textract_client.exceptions.DocumentTooLargeException:
                return jsonify({'error': 'The document is too large for processing. Please consider reducing the file size.'}), 400
            except Exception as e:
                print(f"OCR processing error: {e}")
                return jsonify({'error': 'Error processing OCR'}), 500

            return jsonify({'message': 'PDF uploaded and OCR started', 'file': file.filename}), 200

        return jsonify({'error': 'Invalid file type, only PDFs are accepted'}), 400

    except Exception as e:
        print(f"Error occurred in upload_pdf: {traceback.format_exc()}")
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/status/<filename>', methods=['GET'])
def get_status(filename):
    if filename not in pdf_files:
        return jsonify({'error': 'File not found'}), 404
    
    # Verificar status do job no Textract
    try:
        response = textract_client.get_document_analysis(JobId=pdf_files[filename]['job_id'])
        pdf_files[filename]['status'] = response['JobStatus']
    except Exception as e:
        print(f"Error checking job status: {e}")
        return jsonify({'error': 'Error checking job status'}), 500
    
    return jsonify(pdf_files[filename]), 200

@app.route('/status', methods=['GET'])
def get_all_status():
    return jsonify(pdf_files), 200

@app.route('/pdf/<filename>', methods=['GET'])
def get_pdf_data(filename):
    txt_file_path = os.path.join(RESULTS_FOLDER, f'{filename}.txt')
    if os.path.exists(txt_file_path):
        with open(txt_file_path, 'r') as file:
            return jsonify({'data': file.read()}), 200
    return jsonify({'error': 'File not found'}), 404

if __name__ == '__main__':
    app.run(debug=True, port=5000)


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\ocr_processor.py:
import boto3
import time

def process_document(document):
    # Inicializa o cliente do Textract
    textract = boto3.client('textract')
    
    # Inicia o processamento do documento
    response = textract.start_document_text_detection(
        DocumentLocation={'S3Object': {'Bucket': 'YOUR_BUCKET_NAME', 'Name': document}}
    )

    # Salvar o JobId para verificar o status do processamento
    job_id = response['JobId']
    
    # Aguardar at√© que o Textract conclua o processamento
    while True:
        response = textract.get_document_text_detection(JobId=job_id)
        if 'JobStatus' in response and response['JobStatus'] in ['SUCCEEDED', 'FAILED']:
            break
        print("Aguardando...")  # Ou voc√™ pode adicionar uma pausa com time.sleep()
        time.sleep(5)  # Aguardar 5 segundos entre as verifica√ß√µes
    
    return response

def extract_text_and_save(response, output_txt_path):
    with open(output_txt_path, 'w', encoding='utf-8') as txt_file:
        for item in response['Blocks']:
            if item['BlockType'] == 'LINE':
                txt_file.write(item['Text'] + '\n')

# Supondo que voc√™ tenha uma lista de arquivos PDF enviados
uploaded_pdf = 'example.pdf'  # Nome do arquivo PDF que foi enviado
response = process_document(uploaded_pdf)

# Salvar texto extra√≠do
output_txt_path = r"C:\Users\Frank Webber\Documents\GitHub\digita-liza\results\resultado.txt"
extract_text_and_save(response, output_txt_path)


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\requirements.txt:
Flask==2.3.2
Werkzeug==2.3.4
requests==2.28.2
boto3==1.26.7


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\DownloadText.js:
import React from 'react';

const DownloadText = ({ text, filename }) => {
  const downloadFile = () => {
    const blob = new Blob([text], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${filename}.txt`;
    link.click();
  };

  return (
    <div>
      <button onClick={downloadFile} disabled={!text}>
        Baixar Texto Extra√≠do
      </button>
    </div>
  );
};

export default DownloadText;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\OCRButton.js:
import React from 'react';

const OCRButton = ({ filename, onOCR }) => {
  const handleClick = async () => {
    try {
      const response = await fetch(`http://127.0.0.1:5000/pdf/${filename}`, {
        method: 'GET',
      });

      if (!response.ok) {
        throw new Error('Erro ao solicitar OCR');
      }

      const data = await response.json();
      console.log(data);
      onOCR(data); // Chama a fun√ß√£o onOCR passada como prop
    } catch (error) {
      console.error('Erro ao processar OCR:', error);
    }
  };

  return (
    <button onClick={handleClick}>
      Processar OCR
    </button>
  );
};

export default OCRButton;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\PDFDetails.js:
import React, { useState } from 'react';

const PDFDetails = ({ filename }) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await fetch(`/pdf/${filename}`);
      const result = await response.json();
      if (result.data) {
        setData(result.data);
      } else {
        setData("Nenhum texto extra√≠do encontrado.");
      }
    } catch (error) {
      console.error('Erro ao buscar dados:', error);
      setData("Erro ao buscar dados.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={fetchData} disabled={loading}>
        {loading ? 'Carregando...' : 'Ver OCR'}
      </button>
      {data && <pre>{data}</pre>}
    </div>
  );
};

export default PDFDetails;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\PDFList.js:
import React from 'react';
import OCRButton from './OCRButton'; // Importa o OCRButton para cada PDF

const PDFList = ({ pdfs, onSelectPdf }) => {
  return (
    <div>
      <h2>Lista de PDFs Digitalizados</h2>
      <ul>
        {pdfs.map((pdf, index) => (
          <li key={index}>
            <p>{pdf.filename} - {pdf.status}</p>
            <OCRButton filename={pdf.filename} onOCR={onSelectPdf} />
          </li>
        ))}
      </ul>
    </div>
  );
};

export default PDFList;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\Relatorio.js:
import React, { useState } from 'react';

const ConsoleOutput = () => {
    const [messages, setMessages] = useState([]);

    const addMessage = (newMessage) => {
        setMessages((prevMessages) => [...prevMessages, newMessage]);
    };

    const handleUpload = async (file) => {
        addMessage("Iniciando o upload do arquivo para o bucket S3...");

        // Simular upload para S3
        try {
            await uploadFileToS3(file);
            addMessage(`Upload do arquivo ${file.name} conclu√≠do.`);
        } catch (error) {
            addMessage("Ocorreu um erro durante o upload. Tente novamente.");
            return;
        }

        addMessage(`Iniciando o processamento OCR para o arquivo ${file.name}...`);
        
        // Simular processamento OCR
        try {
            await processOCR(file.name);
            addMessage(`Processamento OCR conclu√≠do para o arquivo ${file.name}.`);
            addMessage(`O arquivo ${file.name} foi convertido com sucesso para TXT. Fa√ßa o download agora!`);
        } catch (error) {
            addMessage(`Erro ao processar o arquivo ${file.name}. Verifique se o arquivo √© um PDF v√°lido.`);
        }
    };

    const uploadFileToS3 = (file) => {
        return new Promise((resolve) => {
            setTimeout(resolve, 2000); // Simulando um atraso de 2 segundos
        });
    };

    const processOCR = (filename) => {
        return new Promise((resolve) => {
            setTimeout(resolve, 3000); // Simulando um atraso de 3 segundos
        });
    };

    return (
        <div style={{ background: '#1e1e1e', color: '#ffffff', padding: '20px', borderRadius: '5px', height: '300px', overflowY: 'scroll' }}>
            <h3>Console Output</h3>
            <div>
                {messages.map((msg, index) => (
                    <div key={index}>{msg}</div>
                ))}
            </div>
            <button onClick={() => handleUpload({ name: 'example.pdf' })}>Iniciar Processamento</button>
        </div>
    );
};

export default ConsoleOutput;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\UploadForm.js:
import React, { useState } from 'react';

function UploadForm({ onUploadSuccess }) {
  const [file, setFile] = useState(null);  // Estado para armazenar o arquivo selecionado
  const [isUploading, setIsUploading] = useState(false);  // Estado para controlar o status de upload

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);  // Atualiza o estado com o arquivo selecionado
  };

  const handleUpload = async (event) => {
    event.preventDefault();

    if (!file) {
      alert('Por favor, selecione um arquivo para upload.');
      return;
    }

    const formData = new FormData();
    formData.append('file', file);

    setIsUploading(true);  // Inicia o processo de upload (mostrar indicador, desabilitar bot√£o, etc.)

    try {
      const response = await fetch('http://127.0.0.1:5000/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Erro ao fazer upload do arquivo.');
      }

      alert('Arquivo enviado com sucesso!');
      setFile(null);  // Limpa o arquivo selecionado ap√≥s o upload
      if (onUploadSuccess) {
        onUploadSuccess();  // Atualiza a lista de PDFs ap√≥s o upload
      }
    } catch (error) {
      alert(`Erro ao enviar arquivo: ${error.message}`);
    } finally {
      setIsUploading(false);  // Finaliza o processo de upload (remover indicador, habilitar bot√£o, etc.)
    }
  };

  return (
    <form onSubmit={handleUpload}>
      <input
        type="file"
        accept=".pdf"  // Limita a sele√ß√£o apenas para arquivos PDF
        onChange={handleFileChange}
        disabled={isUploading}  // Desabilita o input durante o upload
      />
      <button type="submit" disabled={isUploading}>
        {isUploading ? 'Enviando...' : 'Enviar PDF'}
      </button>
    </form>
  );
}

export default UploadForm;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\App.js:
import React, { useState, useEffect } from 'react'; 
import PDFList from './components/PDFList';         // Importa o componente para listar PDFs
import UploadForm from './components/UploadForm';     // Importa o componente de upload de arquivos
import PDFDetails from './components/PDFDetails';     // Importa o componente para mostrar detalhes do PDF
import DownloadText from './components/DownloadText'; // Importa o componente para download de texto (se aplic√°vel)
import OCRButton from './components/OCRButton';       // Importa o componente para realizar OCR (se aplic√°vel)
import Relatorio from './components/Relatorio';       // Importa o componente para gerar relat√≥rios (se aplic√°vel)
import './App.css';                                   // Importa os estilos

function App() {
  const [pdfs, setPdfs] = useState([]);              // Estado para armazenar a lista de PDFs
  const [selectedPdf, setSelectedPdf] = useState(null); // Estado para armazenar o PDF selecionado

  // Fun√ß√£o para buscar a lista de PDFs
  const fetchPDFs = async () => {
    try {
      const response = await fetch('http://localhost:5000/status'); // Faz a requisi√ß√£o ao backend
      if (!response.ok) {
        throw new Error('Erro ao buscar o status dos PDFs'); // Lida com erros de resposta
      }
      const data = await response.json();
      // Transforma a resposta em uma lista de objetos com filename e status
      const pdfList = Object.keys(data).map(key => ({ filename: key, status: data[key].status }));
      setPdfs(pdfList); // Atualiza o estado com a lista de PDFs
    } catch (error) {
      console.error('Error fetching PDF status:', error); // Loga o erro no console
    }
  };

  // useEffect para buscar os PDFs ao carregar o componente
  useEffect(() => {
    fetchPDFs(); // Chama a fun√ß√£o fetchPDFs ao montar o componente
  }, []); // O array vazio faz com que o fetch ocorra apenas uma vez, ao montar o componente

  return (
    <div className="App">
      <h1>DigitalizaLaudos</h1> // T√≠tulo do aplicativo
      <UploadForm onUploadSuccess={fetchPDFs} /> {/* Formul√°rio de upload */}
      <PDFList pdfs={pdfs} onSelectPdf={setSelectedPdf} /> {/* Lista de PDFs */}
      {selectedPdf && (  // Exibe os detalhes do PDF selecionado
        <PDFDetails filename={selectedPdf.filename} />
      )}
      {/* Se voc√™ estiver utilizando DownloadText, OCRButton ou Relatorio, adicione-os aqui */}
      {/* <DownloadText /> */}
      {/* <OCRButton /> */}
      {/* <Relatorio /> */}
    </div>
  );
}

export default App;


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\.gitignore:
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*


Conte˙do de C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\package.json:
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


