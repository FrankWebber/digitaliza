backend/.env # CREDENCIAIS DO USUARIO lisa

AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2
S3_BUCKET_NAME=digita-lisa
TEXTRACT_OUTPUT_BUCKET=digita-lisa
TEXTRACT_MAX_RETRIES=3
TEXTRACT_TIMEOUT=60000
JWT_SECRET=mySuperSecretToken


# Credenciais AWS
AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2

# Nome do bucket S3
S3_BUCKET_NAME=digita-lisa

# Parâmetros do Amazon Textract
TEXTRACT_OUTPUT_BUCKET=digita-lisa

# Configurações adicionais
TEXTRACT_MAX_RETRIES=3
TEXTRACT_TIMEOUT=60000

# Parâmetros de segurança (Exemplo de um token JWT ou qualquer outro segredo usado no projeto)
JWT_SECRET=mySuperSecretToken


C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\app.py
from flask import Flask, jsonify, request
from flask_cors import CORS  # Import CORS
import os
import boto3
from ocr_processor import process_ocr  # Ensure this import works correctly
import traceback  # For detailed error logging

require('dotenv').config();
const AWS = require('aws-sdk');

// Configurando as credenciais
AWS.config.update({
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    region: process.env.AWS_REGION,
});

// Agora você pode usar os serviços da AWS
const s3 = new AWS.S3();
const textract = new AWS.Textract();




app = Flask(__name__)
CORS(app)  # Enable CORS for all routes

# Directory for storing PDFs and results
UPLOAD_FOLDER = os.path.join(os.getcwd(), '../pdfs')
RESULTS_FOLDER = os.path.join(os.getcwd(), '../results')

# Create directories if they don't exist
os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULTS_FOLDER, exist_ok=True)

# S3 Bucket name
S3_BUCKET_NAME = 'bucketparaocrlaudos'  # Replace with your S3 bucket name

# List of monitored PDFs and their statuses
pdf_files = {
    'file1.pdf': {'status': 'completed'},
    'file2.pdf': {'status': 'pending'}
}

@app.route('/upload', methods=['POST'])
def upload_pdf():
    try:
        if 'file' not in request.files:
            return jsonify({'error': 'No file sent'}), 400

        file = request.files['file']
        if file.filename == '':
            return jsonify({'error': 'No file selected'}), 400

        if file and file.filename.endswith('.pdf'):
            filepath = os.path.join(UPLOAD_FOLDER, file.filename)
            file.save(filepath)

            # Upload to S3
            try:
                s3_client = boto3.client('s3')
                s3_client.upload_file(filepath, S3_BUCKET_NAME, file.filename)
            except Exception as e:
                print(f"S3 upload error: {e}")
                return jsonify({'error': 'Error uploading to S3'}), 500

            # Process OCR on the uploaded PDF
            try:
                process_ocr(file.filename)  # Ensure this function is defined correctly
                pdf_files[file.filename] = {'status': 'processing'}  # Update status
            except Exception as e:
                print(f"OCR processing error: {e}")
                return jsonify({'error': 'Error processing OCR'}), 500

            return jsonify({'message': 'PDF uploaded and OCR started', 'file': file.filename}), 200

        return jsonify({'error': 'Invalid file type'}), 400

    except Exception as e:
        print(f"Error occurred in upload_pdf: {traceback.format_exc()}")  # Log detailed traceback
        return jsonify({'error': 'Internal server error'}), 500

@app.route('/status', methods=['GET'])
def get_status():
    return jsonify(pdf_files), 200

@app.route('/pdf/<filename>', methods=['GET'])
def get_pdf_data(filename):
    if filename in pdf_files:
        txt_file_path = os.path.join(RESULTS_FOLDER, f'{filename}.txt')
        if os.path.exists(txt_file_path):
            with open(txt_file_path, 'r') as file:
                return jsonify({'data': file.read()}), 200
    return jsonify({'error': 'File not found'}), 404

if __name__ == '__main__':
    app.run(debug=True, port=5000)  # Ensure the correct port is specified


C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\ocr_processor.py
import boto3
import os

def process_ocr(pdf_filename):
    s3_client = boto3.client('s3')
    bucket_name = 'bucketparaocrlaudos'  # Nome do bucket S3

    # Extrair o conteúdo do PDF do S3
    response = s3_client.get_object(Bucket=bucket_name, Key=pdf_filename)
    pdf_bytes = response['Body'].read()

    client = boto3.client('textract')
    
    response = client.analyze_document(
        Document={'Bytes': pdf_bytes},
        FeatureTypes=["TABLES", "FORMS"]
    )

    blocks = response['Blocks']
    extracted_text = "\n".join([block['Text'] for block in blocks if block['BlockType'] == 'LINE'])

    # Caminho para salvar o arquivo .txt
    txt_file_path = os.path.join(os.path.dirname(__file__), '../results', f'{os.path.splitext(pdf_filename)[0]}.txt')
    
    # Verifica se o diretório de resultados existe e cria, se não existir
    if not os.path.exists(os.path.dirname(txt_file_path)):
        os.makedirs(os.path.dirname(txt_file_path))

    # Salvar o texto extraído em um arquivo .txt
    with open(txt_file_path, 'w') as txt_file:
        txt_file.write(extracted_text)

    return extracted_text  # Ou retorne outra coisa conforme necessário

C:\Users\Frank Webber\Documents\GitHub\digita-liza\backend\requirements.txt
Flask==2.3.2
Werkzeug==2.3.4
requests==2.28.2
boto3==1.26.7

C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\App.js
// App.js in the frontend folder 
import React, { useState, useEffect } from 'react';
import PDFList from './components/PDFList';
import UploadForm from './components/UploadForm';  // Import UploadForm
import PDFDetails from './components/PDFDetails';   // Import PDFDetails
import ConsoleOutput from './components/Relatorio';  // Import ConsoleOutput
import './App.css';

function App() {
  const [pdfs, setPdfs] = useState([]);
  const [selectedPdf, setSelectedPdf] = useState(null); // State for selected PDF

  useEffect(() => {
    // Change this URL if your backend is hosted elsewhere
    fetch('http://localhost:5000/status') 
      .then(response => response.json())
      .then(data => {
        const pdfList = Object.keys(data).map(key => ({ filename: key, status: data[key].status }));
        setPdfs(pdfList);
      })
      .catch(error => console.error('Error fetching PDF status:', error));
  }, []);

  return (
    <div className="App">
      <h1>DigitalizaLaudos</h1>
      <UploadForm />  {/* Add the upload form */}
      <PDFList pdfs={pdfs} onSelectPdf={setSelectedPdf} /> {/* Pass the selection function */}
      {selectedPdf && (  // Display details of the selected PDF
        <PDFDetails filename={selectedPdf.filename} />
      )}
      <ConsoleOutput />  {/* Add the ConsoleOutput component */}
    </div>
  );
}

export default App;

C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\package.json
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

C:\Users\Frank Webber\Documents\GitHub\digita-liza\pdfs\MEMO_N_1305_2024_GPREV_SEDUC_Anexo.pdf

C:\Users\Frank Webber\Documents\GitHub\digita-liza\results\MEMO_N_1305_2024_GPREV_SEDUC_Anexo.zip

C:\Users\Frank Webber\Documents\GitHub\digita-liza\.gitignore
# Ignorar o ambiente virtual do Python
venv/

# Ignorar pastas de resultados e PDFs
backend/pdfs/
backend/results/

# Ignorar arquivos de configuração do sistema
.DS_Store
Thumbs.db

# Ignorar arquivos de log
*.log

# Ignorar arquivos de cache do Node.js
node_modules/
npm-debug.log
yarn-error.log

# Ignorar arquivos do sistema de controle de versão
.git/

C:\Users\Frank Webber\Documents\GitHub\digita-liza\LEIAME.txt
# Digita-Lisa

O **Digita-Lisa** é um sistema de digitalização e extração de informações automatizadas de documentos com integração ao Amazon Textract, projetado para auxiliar a Junta Médica Pericial do Amazonas a processar laudos médicos e outros documentos.

## Funcionalidades

- Extração de texto, tabelas e formulários de documentos digitalizados.
- Suporte a múltiplas páginas e diferentes tipos de documentos (PDF, imagens, etc).
- Automação do reconhecimento de manuscritos, assinaturas e campos de valor-chave.
- Integração com o Amazon S3 para armazenamento de documentos processados.

## Pré-requisitos

- Conta AWS ativa com permissões para utilizar o **Amazon Textract** e **Amazon S3**.
- Node.js e npm instalados localmente.

## Instalação

1. Clone o repositório:

    ```bash
    git clone https://github.com/seuprojeto/digita-lisa.git
    ```

2. Navegue até o diretório do projeto:

    ```bash
    cd digita-lisa
    ```

3. Instale as dependências do projeto:

    ```bash
    npm install
    ```

4. Configure as variáveis de ambiente no arquivo `.env` (ver instruções abaixo).

5. Execute o projeto localmente:

    ```bash
    npm start
    ```

## Configuração do .env

O arquivo `.env` precisa ser configurado com as credenciais AWS e informações do bucket S3. Veja a seção de variáveis de ambiente para mais detalhes.

### Exemplo de configuração `.env`:

```bash
AWS_ACCESS_KEY_ID=AKIAX6UI6HHM6PW3XSHS
AWS_SECRET_ACCESS_KEY=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
AWS_REGION=us-west-2
S3_BUCKET_NAME=digita-lisa

C:\Users\Frank Webber\Documents\GitHub\digita-liza\package.json
{
  "dependencies": {
    "aws-sdk": "^2.1691.0",
    "cors": "^2.8.5"
  }
}

C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\DownloadText.js
import React from 'react';

const DownloadText = ({ text, filename }) => {
  const downloadFile = () => {
    const blob = new Blob([text], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${filename}.txt`;
    link.click();
  };

  return (
    <div>
      <button onClick={downloadFile} disabled={!text}>
        Baixar Texto Extraído
      </button>
    </div>
  );
};

export default DownloadText;

C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\OCRButton.js
import React from 'react';

const OCRButton = ({ filename, onOCR }) => {
  const handleClick = async () => {
    try {
      const response = await fetch(`http://127.0.0.1:5000/pdf/${filename}`, {
        method: 'GET',
      });

      if (!response.ok) {
        throw new Error('Erro ao solicitar OCR');
      }

      const data = await response.json();
      console.log(data);
      onOCR(data); // Chama a função onOCR passada como prop
    } catch (error) {
      console.error('Erro ao processar OCR:', error);
    }
  };

  return (
    <button onClick={handleClick}>
      Processar OCR
    </button>
  );
};

export default OCRButton;

C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\PDFDetails.js
import React, { useState } from 'react';

const PDFDetails = ({ filename }) => {
  const [data, setData] = useState(null);

  const fetchData = () => {
    fetch(`/pdf/${filename}`)
      .then(response => response.json())
      .then(data => {
        if (data.data) {
          setData(data.data);
        } else {
          setData("Nenhum texto extraído encontrado.");
        }
      });
  };

  return (
    <div>
      <button onClick={fetchData}>Ver OCR</button>
      {data && <pre>{data}</pre>}
    </div>
  );
}

export default PDFDetails;

C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\PDFList.js
import React from 'react';
import PDFDetails from './PDFDetails';

const PDFList = ({ pdfs }) => {
  return (
    <div>
      <h2>Lista de PDFs Digitalizados</h2>
      <ul>
        {pdfs.map((pdf, index) => (
          <li key={index}>
            <p>{pdf.filename} - {pdf.status}</p>
            <PDFDetails filename={pdf.filename} />
          </li>
        ))}
      </ul>
    </div>
  );
};

export default PDFList;

C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\Relatorio.js
import React, { useState } from 'react';

const ConsoleOutput = () => {
    const [messages, setMessages] = useState([]);

    const addMessage = (newMessage) => {
        setMessages((prevMessages) => [...prevMessages, newMessage]);
    };

    const handleUpload = async (file) => {
        addMessage("Iniciando o upload do arquivo para o bucket S3...");

        // Simular upload para S3
        try {
            await uploadFileToS3(file);
            addMessage(`Upload do arquivo ${file.name} concluído.`);
        } catch (error) {
            addMessage("Ocorreu um erro durante o upload. Tente novamente.");
            return;
        }

        addMessage(`Iniciando o processamento OCR para o arquivo ${file.name}...`);
        
        // Simular processamento OCR
        try {
            await processOCR(file.name);
            addMessage(`Processamento OCR concluído para o arquivo ${file.name}.`);
            addMessage(`O arquivo ${file.name} foi convertido com sucesso para TXT. Faça o download agora!`);
        } catch (error) {
            addMessage(`Erro ao processar o arquivo ${file.name}. Verifique se o arquivo é um PDF válido.`);
        }
    };

    const uploadFileToS3 = (file) => {
        return new Promise((resolve) => {
            setTimeout(resolve, 2000); // Simulando um atraso de 2 segundos
        });
    };

    const processOCR = (filename) => {
        return new Promise((resolve) => {
            setTimeout(resolve, 3000); // Simulando um atraso de 3 segundos
        });
    };

    return (
        <div style={{ background: '#1e1e1e', color: '#ffffff', padding: '20px', borderRadius: '5px', height: '300px', overflowY: 'scroll' }}>
            <h3>Console Output</h3>
            <div>
                {messages.map((msg, index) => (
                    <div key={index}>{msg}</div>
                ))}
            </div>
            <button onClick={() => handleUpload({ name: 'example.pdf' })}>Iniciar Processamento</button>
        </div>
    );
};

export default ConsoleOutput;

C:\Users\Frank Webber\Documents\GitHub\digita-liza\frontend\src\components\UploadForm.js
import React, { useState } from 'react';

const UploadForm = () => {
  const [file, setFile] = useState(null);

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);
  };

  const handleUpload = async (event) => {
    event.preventDefault();
    if (!file) {
      alert('Por favor, selecione um arquivo para upload.');
      return;
    }

    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await fetch('http://127.0.0.1:5000/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Erro ao fazer upload do arquivo');
      }

      const data = await response.json();
      console.log(data);
      alert('Arquivo enviado com sucesso!');
    } catch (error) {
      console.error('Erro ao fazer upload do arquivo:', error);
      alert('Erro ao enviar arquivo: ' + error.message);
    }
  };

  return (
    <form onSubmit={handleUpload}>
      <input type="file" accept=".pdf" onChange={handleFileChange} />
      <button type="submit">Enviar PDF</button>
    </form>
  );
};

export default UploadForm;

